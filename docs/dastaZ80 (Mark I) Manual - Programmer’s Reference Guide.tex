\documentclass[a4paper,11pt]{article}
\usepackage[UKenglish]{babel}
\usepackage[table]{xcolor}
\usepackage{graphicx}
\usepackage{courier}
\usepackage{color}
\usepackage{array}
\usepackage{pstricks}
\usepackage{parskip}
\usepackage[bottom]{footmisc}
\usepackage{fancyhdr}
\usepackage{multirow}
\usepackage{longtable}
% the hyperref package must always be the last package to be included
\usepackage[pdftex,
            pdfusetitle,
            pdfsubject={Programmer's Reference Guide for dastaZ80 homebrew computer},
            pdfkeywords={Z80, homebrew computer, Operating System, OS, programmer, reference, guide}
        ]{hyperref}

\hypersetup{
    colorlinks = true,
    linkcolor = blue,
    anchorcolor = blue,
    citecolor = blue,
    filecolor = blue,
    urlcolor = blue
}

\setlength\parindent{0pt}

\begin{document}
    \pagestyle{empty}
    % ==========================================================================
    % Cover page
    % ==========================================================================
    \begin{pspicture}(8.5,11)
        \rput[b](3.5,8){
            \parbox{7in}{
                \begin{flushright}
                    \Huge\bfseries\sffamily dastaZ80 Mark I\\ Programmer's Reference Guide
                \end{flushright}
            }
        }
        \uput[0](0,0){\color{blue}\rule{7in}{0.5ex}}
    \end{pspicture}
    \title{dastaZ80 Programmer's Reference Guide}
    \author{David Asta}
    \date{1 October 2022}

    \pagebreak
    % ==========================================================================
    % Header & Footer
    % ==========================================================================
    \pagestyle{fancy}
    \fancyhf{}
    \fancyhead[R]{dastaZ80 Mark I Programmer's Reference Guide}
    % ==========================================================================
    \section*{Disclaimer}
    % ==========================================================================
    The products described in this manual are intended for educational purposes,
    and should not be used for controlling any machinery, critical component in
    life support devices or any system in which failure could result in personal
    injury if any of the described here products fail.
    
    These products are subject to continuous development and improvement. All
    information of a technical nature and particulars of the products and its
    use are given by the author in good faith. However, it is acknowledged that
    there may be errors or omissions in this manual. Therefore, the author
    cannot accept any liability for any loss or damage arising from the use of
    any information or particulars in this manual.

    % ==========================================================================
    \section*{Licenses}
    % ==========================================================================
    \small
    \textbf{Hardware} is licensed under the \textbf{Creative Commons
    Attribution-ShareAlike 4.0 International License}
    
    \hspace{1cm}http://creativecommons.org/licenses/by-sa/4.0/
    
    \textbf{Software} is licensed under \textbf{The MIT License}
    
    \hspace{1cm}https://opensource.org/licenses/MIT
    
    \textbf{Documentation} is licensed under the \textbf{Creative Commons
    Attribution-ShareAlike 4.0 International License}
    
    \hspace{1cm}http://creativecommons.org/licenses/by-sa/4.0/

    \normalsize

    \hrulefill

    \textcopyright 2022 David Asta

    \pagebreak
    % ==========================================================================
    \section*{Document Conventions}
    % ==========================================================================
    The following conventions are used in this manual:

    \begin{center}
        \begin{tabular}{c m{9cm}}
            \hline
            MUST & MUST denotes that the definition is and absolute
            requirement.\\
            \hline
            SHOULD & SHOULD denotes that it is recommended, but that there may
            exist valid reasons to ignore it.\\
            \hline
            \textbf{DEVICE} & Device names are displayed in bold all upper case 
            letters, and refer to hardware devices.\\
            \hline
            \texttt{Courier} & Text appearing in the \texttt{Courier} font 
            represents either an OS System Variable\footnote{System Variables
            are identifiers for specific \textbf{MEMORY} addresses that can be
            used to read statuses and to pass information between routines or 
            programs.}, a Z80 CPU Register or a Z80 Flag.\\
            \hline
            \texttt{0x14B0} & Numbers prefixed by 0x indicate an Hexadecimal value.
            Unless specified, memory addresses are always expressed in
            Hexadecimal.\\
            \hline
            F\_abcdef & Text starting with F\_ refers to the name of an OS 
            routine that can be called via Jumpblocks. \\
            \hline
            \textit{jp} abcdef & Refers to the Z80 mnemonic for \textit{jump},
            which transfers the CPU Program Counter to a specific \textbf{MEMORY}
            address.\\
            \hline
        \end{tabular}
    \end{center}

    The CompactFlash card is referred as \textbf{DISK}.

    The 80 column VGA output is referred as \textbf{CONSOLE}.
    
    The Operating System may be referred as DZOS, dzOS or simply OS.

    \textbf{MEMORY} refers to both \textbf{ROM} and \textbf{RAM}.

    In the list of routines, the \textbf{Destroys} lists the \textbf{CPU}
    registers and \textbf{MEMORY} System Variables that are destroyed by the
    routine in question. But bare in mind that a routine may call other routines
    that may destroy other registers and variables. Refer to the \textbf{Calls}
    list to check the entire flow. By \textit{Destroys} is understood that the
    listed register or variable value is overwritten within the routine.

    \textbf{FIXME} ???? WHERE IS THE FOOTNOTE ????
    
    \pagebreak
    % ==========================================================================
    \section*{Related Documentation}
    % ==========================================================================
    \hspace{1cm}{\LARGE dastaZ80 User's Manual}
    
    \hspace{1cm}{\LARGE dastaZ80 Technical Reference Manual}

    \hspace{1cm}{\LARGE https://github.com/dasta400/dzOS}

    \pagebreak
    % ==========================================================================
    \tableofcontents
    % ==========================================================================

    \pagebreak
    % ==========================================================================
    % Header & Footer
    % ==========================================================================
    \pagestyle{fancy}
    \fancyhf{}
    \fancyhead[R]{dastaZ80 Mark I Programmer's Reference Guide}
    \fancyfoot[R]{\thepage}
    \setcounter{page}{1}
    % ==========================================================================
    \section{Memory Map}
    % ==========================================================================
    
    % ==========================================================================
    \subsection{ROM}
    % ==========================================================================
    \begin{tabular}{ |m{1.3cm}|m{1.3cm}|m{3.3cm}|m{2.7cm}|>{\raggedleft\arraybackslash}m{2cm}| }
        \hline
        \rowcolor{lightgray}
        \multicolumn{2}{|c|}{Address} &
        \multicolumn{2}{|c|}{Description} &
        Size (bytes) \\
        \hline
        \hline
        \texttt{0x0008} & \texttt{0x01D9} & init SIO/2 & \textbf{\multirow{3}{4em}{BIOS}} & 466 \\
        \texttt{0x01DA} & \texttt{0x133F} & BIOS code & & 4,462 \\
        \texttt{0x1340} & \texttt{0x13BF} & BIOS Jumpblock & & 128 \\
        \hline
        \texttt{0x13C0} & \texttt{0x267F} & Kernel code & \textbf{\multirow{3}{4em}{Kernel}} & 4,800 \\
        \texttt{0x2670} & \texttt{0x267F} & dzOS version build & & 16 \\
        \texttt{0x2680} & \texttt{0x277F} & Kernel Jumpblock & & 256 \\
        \hline
        \texttt{0x2780} & \texttt{0x3B3F} & CLI code & \textbf{CLI} & 5,056 \\
        \hline
        \texttt{0x3B40} & \texttt{0x3C3F} & Bootstrap & \textbf{BOOTSTRAP} & 256 \\
        \hline
        \texttt{0x3C40} & \texttt{0x3FFF} & Free & & 960 \\
        \hline
    \end{tabular}

    % ==========================================================================
    \subsection{RAM}
    % ==========================================================================
    \label{sec:ram_memmap}

    \begin{longtable}{ |l|l|l|l|l| }\hline
        \hline
        \rowcolor{lightgray}
        \multicolumn{2}{|c|}{Address} &
        \multicolumn{2}{|c|}{Description} &
        Size (bytes) \\
        \hline
        \hline
        \endfirsthead

        \hline
        \rowcolor{lightgray}
        \multicolumn{2}{|c|}{Address} &
        \multicolumn{2}{|c|}{Description} &
        Size (bytes) \\
        \hline
        \hline
        \endhead

        \texttt{0x4000} & \texttt{0x401F} & \multicolumn{2}{|l|}{\textbf{Stack}} & 32\\
        \hline
        \texttt{0x4020} & \texttt{0x4174} & \multicolumn{2}{|l|}{\textbf{System Variables}} & 341\\
        \hline
        \multicolumn{2}{|c|}{\multirow{9}{*}{\textbf{SIO}}} & \texttt{0x4020} & SIO\_CH\_A\_BUFFER & 64\\
        \multicolumn{2}{|c|}{} & \texttt{0x4060} & SIO\_CH\_A\_IN\_PTR & 2\\
        \multicolumn{2}{|c|}{} & \texttt{0x4062} & SIO\_CH\_A\_RD\_PTR & 2\\
        \multicolumn{2}{|c|}{} & \texttt{0x4064} & SIO\_CH\_A\_BUFFER\_USED & 1\\
        \multicolumn{2}{|c|}{} & \texttt{0x4065} & SIO\_CH\_B\_BUFFER & 64\\
        \multicolumn{2}{|c|}{} & \texttt{0x40A5} & SIO\_CH\_B\_IN\_PTR & 2\\
        \multicolumn{2}{|c|}{} & \texttt{0x40A7} & SIO\_CH\_B\_RD\_PTR & 2\\
        \multicolumn{2}{|c|}{} & \texttt{0x40A9} & SIO\_CH\_B\_BUFFER\_USED & 1\\
        \multicolumn{2}{|c|}{} & \texttt{0x40AA} & SIO\_PRIMARY\_IO & 1\\
        \hline
        \multicolumn{2}{|c|}{\multirow{2}{*}{\textbf{CF Superblock}}} & \texttt{0x40AB} & CF\_is\_formatted & 1\\
        \multicolumn{2}{|c|}{} & \texttt{0x40AC} & CF\_cur\_partition & 1\\
        \multicolumn{2}{|c|}{} & \texttt{0x40AD} & CF\_cur\_sector & 2\\
        \hline
        \multicolumn{2}{|c|}{\multirow{11}{*}{\textbf{CF BAT}}} & \texttt{0x40BD} & CF\_cur\_file\_attribs & 1\\
        \multicolumn{2}{|c|}{} & \texttt{0x40BE} & CF\_cur\_file\_time\_created & 2\\
        \multicolumn{2}{|c|}{} & \texttt{0x40C0} & CF\_cur\_file\_date\_created & 2\\
        \multicolumn{2}{|c|}{} & \texttt{0x40C2} & CF\_cur\_file\_time\_modified & 2\\
        \multicolumn{2}{|c|}{} & \texttt{0x40C4} & CF\_cur\_file\_date\_modified & 2\\
        \multicolumn{2}{|c|}{} & \texttt{0x40C6} & CF\_cur\_file\_size\_bytes & 2\\
        \multicolumn{2}{|c|}{} & \texttt{0x40C8} & CF\_cur\_file\_size\_sectors & 1\\
        \multicolumn{2}{|c|}{} & \texttt{0x40C9} & CF\_cur\_file\_entry\_number & 2\\
        \multicolumn{2}{|c|}{} & \texttt{0x40CB} & CF\_cur\_file\_1st\_sector & 2\\
        \multicolumn{2}{|c|}{} & \texttt{0x40CD} & CF\_cur\_file\_load\_addr & 2\\
        \hline
        \multicolumn{2}{|c|}{\multirow{5}{*}{\textbf{CLI}}} & \texttt{0x40CF} & CLI\_buffer\_cmd & 16\\
        \multicolumn{2}{|c|}{} & \texttt{0x40DF} & CLI\_buffer\_parm1\_val & 16\\
        \multicolumn{2}{|c|}{} & \texttt{0x40EF} & CLI\_buffer\_parm2\_val & 16\\
        \multicolumn{2}{|c|}{} & \texttt{0x40FF} & CLI\_buffer\_pgm & 32\\
        \multicolumn{2}{|c|}{} & \texttt{0x411F} & CLI\_buffer\_full\_cmd & 64\\
        \hline
        \multicolumn{2}{|c|}{\multirow{4}{*}{\textbf{Generic}}} & \texttt{0x415F} & tmp\_addr1 & 2\\
        \multicolumn{2}{|c|}{} & \texttt{0x4161} & tmp\_addr2 & 2\\
        \multicolumn{2}{|c|}{} & \texttt{0x4163} & tmp\_addr3 & 2\\
        \multicolumn{2}{|c|}{} & \texttt{0x4165} & tmp\_byte & 1\\
        \hline
        \multicolumn{2}{|c|}{\multirow{9}{*}{\textbf{RTC}}} & \texttt{0x4166} & RTC\_hour & 1\\
        \multicolumn{2}{|c|}{} & \texttt{0x4167} & RTC\_minutes & 1\\
        \multicolumn{2}{|c|}{} & \texttt{0x4168} & RTC\_seconds & 1\\
        \multicolumn{2}{|c|}{} & \texttt{0x4169} & RTC\_century & 1\\
        \multicolumn{2}{|c|}{} & \texttt{0x416A} & RTC\_year & 1\\
        \multicolumn{2}{|c|}{} & \texttt{0x416B} & RTC\_year4 & 2\\
        \multicolumn{2}{|c|}{} & \texttt{0x416D} & RTC\_month & 1\\
        \multicolumn{2}{|c|}{} & \texttt{0x416E} & RTC\_day & 1\\
        \multicolumn{2}{|c|}{} & \texttt{0x416F} & RTC\_day\_of\_the\_week & 1\\
        \hline
        \multicolumn{2}{|c|}{\textbf{NVRAM (RTC)}} & \texttt{0x4170} & NVRAM\_battery\_status & 1\\
        \hline
        \multicolumn{2}{|c|}{\multirow{2}{*}{\textbf{Math}}} & \texttt{0x4171} & MATH\_CRC & 2\\
        \multicolumn{2}{|c|}{} & \texttt{0x4173} & MATH\_polynomial & 2\\
        \hline
        \texttt{0x4175} & \texttt{0x421F} & \multicolumn{2}{|l|}{\textbf{Reserved for future use}} & 171\\
        \hline
        \texttt{0x4220} & \texttt{0x441F} & \multicolumn{2}{|l|}{\textbf{DISK Buffer}} & 512\\
        \hline
        \texttt{0x4420} & \texttt{0xFFFF} & \multicolumn{2}{|l|}{\textbf{Free RAM}} & 48,096\\
        \hline
      \end{longtable}

    \pagebreak
    % ==========================================================================
    \section{I/O Map}
    % ==========================================================================

    \begin{tabular}{l l l }
        \hline
        \textbf{ROM Paging} & \texttt{0x38} & \\
        \hline
        \multirow{4}{*}{\textbf{SIO}} & \texttt{0x80} & Channel A Control\\
        & \texttt{0x81} & Channel A Data\\
        & \texttt{0x82} & Channel B Control\\
        & \texttt{0x83} & Channel B Data\\
        \hline
        \textbf{CompactFlash Card} & \texttt{0x10} & \\
        \hline
    \end{tabular}

    \pagebreak
    % ==========================================================================
    \section{BIOS Jumpblocks}
    % ==========================================================================

    % ==========================================================================
    \subsection{General Routines}
    % ==========================================================================
    
        % ==========================================================================
        \subsubsection{F\_BIOS\_CBOOT}
        \label{func:fbioscboot}
        % ==========================================================================
        \begin{tabular}{l p{9cm}}
            \hline\textbf{Action}
            & Cold Boot. Executed when the computer is powered on, or after a
            reset by pressing the \textbf{RESET} push-button \\
            \hline\textbf{Entry} & None \\
            \hline\textbf{Exit} & None \\
            \hline\textbf{Destroys} & None \\
            \hline\textbf{Calls} & \textit{jp} F\_BOOSTRAP\_START \\
            \hline
        \end{tabular}

        % ==========================================================================
        \subsubsection{F\_BIOS\_WBOOT}
        \label{func:fbioswboot}
        % ==========================================================================
        \begin{tabular}{l p{9cm}}
            \hline\textbf{Action}
            & Warm Boot. Executed after \textbf{SIO/2} initialisation, or after a
            \textit{reset} command \\
            \hline\textbf{Entry} & None \\
            \hline\textbf{Exit} & None \\
            \hline\textbf{Destroys} & None \\
            \hline\textbf{Calls} & \textit{jp} F\_KRN\_START \\
            \hline
        \end{tabular}

        % ==========================================================================
        \subsubsection{F\_BIOS\_SYSHALT}
        \label{func:fbiossyshalt}
        % ==========================================================================
        \begin{tabular}{l p{9cm}}
            \hline\textbf{Action}
            & Halts the computer. Executed after a \textit{halt} command \\
            \hline\textbf{Entry} & None \\
            \hline\textbf{Exit} & Disables Interrupts (di) \\
            \hline\textbf{Destroys} & None \\
            \hline\textbf{Calls} & None \\
            \hline
        \end{tabular}

    % ==========================================================================
    \subsection{Serial Routines}
    % ==========================================================================

        % ==========================================================================
        \subsubsection{F\_BIOS\_SERIAL\_INIT}
        \label{func:fbiosserialinit}
        % ==========================================================================
        \begin{tabular}{l p{9cm}}
            \hline\multirow[t]{4}{4em}{\textbf{Action}}
            & Initialises \textbf{SIO/2}: sets Channels A and B as 115,000 bps, 
            8N1, Interrupt in all characters \\
            & Configures the interrupt vector to 0x60 \\
            & Sets the CPU to Interrupt Mode 2 \\
            & Enables Interrupts \\
            \hline\textbf{Entry} & None \\
            \hline\textbf{Exit} & None \\
            \hline\textbf{Destroys} & \texttt{A}, \texttt{HL} \\
            \hline\textbf{Calls} 
            & \textit{jp} \hyperref[func:fbioswboot]{F\_BIOS\_WBOOT} \\
            \hline
        \end{tabular}
        
        % ==========================================================================
        \subsubsection{F\_BIOS\_SERIAL\_CONIN\_A}
        \label{func:fbiosserialconina}
        % ==========================================================================
        \begin{tabular}{l p{9cm}}
            \hline\textbf{Action}
            & Reads a character from the \textbf{SIO/2} Channel A \\
            \hline\textbf{Entry} & None \\
            \hline\textbf{Exit} & \texttt{A} = character read \\
            \hline\textbf{Destroys} & \texttt{A} \\
            \hline\textbf{Calls} & None \\
            \hline
        \end{tabular}

        % ==========================================================================
        \subsubsection{F\_BIOS\_SERIAL\_CONIN\_B}
        \label{func:fbiosserialconinb}
        % ==========================================================================
        \begin{tabular}{l p{9cm}}
            \hline\textbf{Action}
            & Reads a character from the \textbf{SIO/2} Channel B \\
            \hline\textbf{Entry} & None \\
            \hline\textbf{Exit} & \texttt{A} = character read \\
            \hline\textbf{Destroys} & \texttt{A} \\
            \hline\textbf{Calls} & None \\
            \hline
        \end{tabular}

        % ==========================================================================
        \subsubsection{F\_BIOS\_SERIAL\_CONOUT\_A}
        \label{func:fbiosserialconouta}
        % ==========================================================================
        \begin{tabular}{l p{9cm}}
            \hline\textbf{Action}
            & Sends a character to the \textbf{SIO/2} Channel A \\
            \hline\textbf{Entry} & \texttt{A} = character to be send \\
            \hline\textbf{Exit} & None \\
            \hline\textbf{Destroys} & None \\
            \hline\textbf{Calls} & None \\
            \hline
        \end{tabular}

        % ==========================================================================
        \subsubsection{F\_BIOS\_SERIAL\_CONOUT\_B}
        \label{func:fbiosserialconoutb}
        % ==========================================================================
        \begin{tabular}{l p{9cm}}
            \hline\textbf{Action}
            & Sends a character to the \textbf{SIO/2} Channel B \\
            \hline\textbf{Entry} & \texttt{A} = character to be send \\
            \hline\textbf{Exit} & None \\
            \hline\textbf{Destroys} & None \\
            \hline\textbf{Calls} & None \\
            \hline
        \end{tabular}

    % ==========================================================================
    \subsection{Compact-Flash (DISK) Routines}
    % ==========================================================================

        % ==========================================================================
        \subsubsection{F\_BIOS\_CF\_INIT}
        \label{func:fbioscfinit}
        % ==========================================================================
        \begin{tabular}{l p{9cm}}
            \hline\textbf{Action}
            & Sets \textbf{DISK} to 8-bit data transfer mode \\
            \hline\textbf{Entry} & None \\
            \hline\textbf{Exit} & None \\
            \hline\textbf{Destroys} & \texttt{A} \\
            \hline\textbf{Calls}
            & \hyperref[func:fbioscfbusy]{F\_BIOS\_CF\_BUSY}\\
            \hline
        \end{tabular}

        % ==========================================================================
        \subsubsection{F\_BIOS\_CF\_BUSY}
        \label{func:fbioscfbusy}
        % ==========================================================================
        \begin{tabular}{l p{9cm}}
            \hline\textbf{Action}
            & Checks if the \textbf{DISK} busy bit (0=ready, 1=busy) and loops until it is not busy \\
            \hline\textbf{Entry} & None \\
            \hline\textbf{Exit} & None \\
            \hline\textbf{Destroys} & \texttt{A} \\
            \hline\textbf{Calls} & None \\
            \hline
        \end{tabular}

        % ==========================================================================
        \subsubsection{F\_BIOS\_CF\_DISKINFO}
        \label{func:fbioscfdiskinfo}
        % ==========================================================================
        \begin{tabular}{l p{9cm}}
            \hline\textbf{Action}
            & Executes an \textit{Identify Drive} command \\
            \hline\textbf{Entry} & None \\
            \hline\textbf{Exit} & None \\
            \hline\textbf{Destroys} & \texttt{A}, \texttt{B}, \texttt{HL},
            \texttt{CF\_BUFFER\_START} \\
            \hline\textbf{Calls}
            & \hyperref[func:fbioscfbusy]{F\_BIOS\_CF\_BUSY}\\
            \hline
        \end{tabular}

        % ==========================================================================
        \subsubsection{F\_BIOS\_CF\_SET\_LBA}
        \label{func:fbioscfsetlba}
        % ==========================================================================
        \begin{tabular}{l p{9cm}}
            \hline\textbf{Action}
            & Sets Sector count and LBA address \\
            \hline\multirow[t]{4}{4em}{\textbf{Entry}}
            & \texttt{E} = sector address LBA 0 (bits 0-7) \\
            & \texttt{D} = sector address LBA 1 (bits 8-15) \\
            & \texttt{C} = sector address LBA 2 (bits 16-23) \\
            & \texttt{B} = sector address LBA 3 (bits 24-27) \\
            \hline\textbf{Exit} & None \\
            \hline\textbf{Destroys} & \texttt{A} \\
            \hline\textbf{Calls}
            & \hyperref[func:fbioscfbusy]{F\_BIOS\_CF\_BUSY}\\
            \hline
        \end{tabular}

        % ==========================================================================
        \subsubsection{F\_BIOS\_CF\_READ\_SEC}
        \label{func:fbioscfreadsec}
        % ==========================================================================
        \begin{tabular}{l p{9cm}}
            \hline\textbf{Action}
            & Reads a Sector (512 bytes), from the \textbf{DISK} and places the bytes into the \texttt{CF\_BUFFER\_START} \\
            \hline\multirow[t]{4}{4em}{\textbf{Entry}}
            & \texttt{E} = sector address LBA 0 (bits 0-7) \\
            & \texttt{D} = sector address LBA 1 (bits 8-15) \\
            & \texttt{C} = sector address LBA 2 (bits 16-23) \\
            & \texttt{B} = sector address LBA 3 (bits 24-27) \\
            \hline\textbf{Exit} & \texttt{CF\_BUFFER\_START} contains the 512 bytes read \\
            \hline\textbf{Destroys} & \texttt{A}, \texttt{B}, \texttt{HL}, \texttt{CF\_BUFFER\_START} \\
            \hline\multirow[t]{2}{4em}{\textbf{Calls}}
            & \hyperref[func:fbioscfsetlba]{F\_BIOS\_CF\_SET\_LBA}\\
            & \hyperref[func:fbioscfbusy]{F\_BIOS\_CF\_BUSY}\\
            \hline
        \end{tabular}

        % ==========================================================================
        \subsubsection{F\_BIOS\_CF\_WRITE\_SEC}
        \label{func:fbioscfwritesec}
        % ==========================================================================
        \begin{tabular}{l p{9cm}}
            \hline\textbf{Action}
            & Writes a Sector (512 bytes), from the \texttt{CF\_BUFFER\_START} into the \textbf{DISK}\\
            \hline\multirow[t]{4}{4em}{\textbf{Entry}} 
            & \texttt{E} = sector address LBA 0 (bits 0-7) \\
            & \texttt{D} = sector address LBA 1 (bits 8-15) \\
            & \texttt{C} = sector address LBA 2 (bits 16-23) \\
            & \texttt{B} = sector address LBA 3 (bits 24-27) \\
            \hline\textbf{Exit} & \texttt{CF\_BUFFER\_START} contains the 512 bytes written \\
            \hline\textbf{Destroys} & \texttt{A}, \texttt{B}, \texttt{HL} \\
            \hline\multirow[t]{2}{4em}{\textbf{Calls}} 
            & \hyperref[func:fbioscfsetlba]{F\_BIOS\_CF\_SET\_LBA}\\
            & \hyperref[func:fbioscfbusy]{F\_BIOS\_CF\_BUSY}\\
            \hline
        \end{tabular}

    \pagebreak
    % ==========================================================================
    \section{Kernel Jumpblocks}
    % ==========================================================================

    % ==========================================================================
    \subsection{Serial Routines}
    % ==========================================================================

        % ==========================================================================
        \subsubsection{F\_KRN\_SERIAL\_WRSTR}
        \label{func:fkrnserialwrstr}
        % ==========================================================================
        \begin{tabular}{l p{9cm}}
            \hline\multirow[t]{4}{4em}{\textbf{Action}}
            & Outputs a string, terminated with Carriage Return to the 
            \textbf{CONSOLE}.\\
            \hline\textbf{Entry} 
            & \texttt{HL} = address in \textbf{MEMORY} where the first character
            of the string to be output is.\\
            \hline\textbf{Exit} & None \\
            \hline\textbf{Destroys} & \texttt{A}, \texttt{HL} \\
            \hline\textbf{Calls}
            & \hyperref[func:fbiosserialconouta]{F\_BIOS\_SERIAL\_CONOUT\_A}\\
            \hline
        \end{tabular}

        % ==========================================================================
        \subsubsection{F\_KRN\_SERIAL\_SETFGCOLR}
        \label{func:fkrnserialsetfgcolr}
        % ==========================================================================
        \begin{tabular}{l p{9cm}}
            \hline\multirow[t]{4}{4em}{\textbf{Action}}
            & Set the colour that will be used for the foreground (text). \\
            & The colour will remain until a different one is set. \\
            \hline\textbf{Entry} & \texttt{A} = Colour number (as listed in 
            \hyperref[sec:appendixes]{Appendixes} section) \\
            \hline\textbf{Exit} & None \\
            \hline\textbf{Destroys} & \texttt{B}, \texttt{DE} \\
            \hline\multirow[t]{2}{4em}{\textbf{Calls}} 
            & \hyperref[func:fbiosserialconouta]{F\_BIOS\_SERIAL\_CONOUT\_A}\\
            & \textit{jp} \hyperref[func:fkrnserialsendansicode]{F\_KRN\_SERIAL\_SEND\_ANSI\_CODE}\\
            \hline
        \end{tabular}

        % ==========================================================================
        \subsubsection{F\_KRN\_SERIAL\_WRSTRCLR}
        \label{func:fkrnserialwrstrclr}
        % ==========================================================================
        \begin{tabular}{l p{9cm}}
            \hline\textbf{Action}
            & Outputs a string, terminated with Carriage Return to the 
            \textbf{CONSOLE}, with a specific foreground colour. \\
            \hline\multirow[t]{2}{4em}{\textbf{Entry}}
            & \texttt{A} = Colour number (as listed in 
            \hyperref[sec:appendixes]{Appendixes} section) \\
            & \texttt{HL} = address in \textbf{MEMORY} where the first character
            of the string to be output is.\\
            \hline\textbf{Exit} & None \\
            \hline\textbf{Destroys} & \texttt{B}, \texttt{DE} \\
            \hline\multirow[t]{2}{4em}{\textbf{Calls}} 
            & \hyperref[func:fkrnserialsetfgcolr]{F\_KRN\_SERIAL\_SETFGCOLR}\\
            & \textit{jp} \hyperref[func:fkrnserialwrstr]{F\_KRN\_SERIAL\_WRSTR}\\
            \hline
        \end{tabular}

        % ==========================================================================
        \subsubsection{F\_KRN\_SERIAL\_WR6DIG\_NOLZEROS}
        \label{func:fkrnserialwr6dignolzeros}
        % ==========================================================================
        \begin{tabular}{l p{9cm}}
            \hline\multirow[t]{2}{4em}{\textbf{Action}}
            & Outputs to the \textbf{CONSOLE} a string of ASCII characters 
            representing a number, without outputing the leading zeros.\\
            & (.e.g. 30 30 31 32 30 34 is 001204, but the output wil be 1024)\\
            \hline\textbf{Entry} 
            & \texttt{IX} = address in \textbf{MEMORY} where the ASCII 
            characters are stored.\\
            \hline\textbf{Exit} & None \\
            \hline\textbf{Destroys} & \texttt{A}, \texttt{B}, \texttt{DE}, \texttt{IX} \\
            \hline\textbf{Calls}
            & \hyperref[func:fbiosserialconouta]{F\_BIOS\_SERIAL\_CONOUT\_A}\\
            \hline
        \end{tabular}

        % ==========================================================================
        \subsubsection{F\_KRN\_SERIAL\_RDCHARECHO}
        \label{func:fkrnserialrdcharecho}
        % ==========================================================================
        \begin{tabular}{l p{9cm}}
            \hline\textbf{Action}
            & Reads with echo. Reads a character from the \textbf{SIO/2} Channel
            A, and outputs it to the \textbf{CONSOLE}.\\
            \hline\textbf{Entry} & None \\
            \hline\textbf{Exit} & \texttt{A} = read character. \\
            \hline\textbf{Destroys} & None \\
            \hline\multirow[t]{2}{4em}{\textbf{Calls}}
            & \hyperref[func:fbiosserialconina]{F\_BIOS\_SERIAL\_CONIN\_A}\\
            & \hyperref[func:fbiosserialconouta]{F\_BIOS\_SERIAL\_CONOUT\_A}\\
            \hline
        \end{tabular}

        % ==========================================================================
        \subsubsection{F\_KRN\_SERIAL\_EMPTYLINES}
        \label{func:fkrnserialemptylines}
        % ==========================================================================
        \begin{tabular}{l p{9cm}}
            \hline\textbf{Action}
            & Outputs \textit{n} number of empty lines to the \textbf{CONSOLE}.\\
            \hline\textbf{Entry} & \texttt{B} = number (\textit{n}) of empty
            lines to output. \\
            \hline\textbf{Exit} & None \\
            \hline\textbf{Destroys} & \texttt{A} \\
            \hline\textbf{Calls}
            & \hyperref[func:fbiosserialconouta]{F\_BIOS\_SERIAL\_CONOUT\_A}\\
            \hline
        \end{tabular}

        % ==========================================================================
        \subsubsection{F\_KRN\_SERIAL\_PRN\_NIBBLE}
        \label{func:fkrnserialprnnibble}
        % ==========================================================================
        \begin{tabular}{l p{9cm}}
            \hline\textbf{Action}
            & Outputs a single hexadecimal nibble in hexadecimal notation.\\
            \hline\textbf{Entry}
            & \texttt{A} = nibble to output. Nibble will be the less significant 
            4 bits of the byte.\\
            \hline\textbf{Exit} & None \\
            \hline\textbf{Destroys} & \texttt{A} \\
            \hline\textbf{Calls}
            & \hyperref[func:fbiosserialconouta]{F\_BIOS\_SERIAL\_CONOUT\_A}\\
            \hline
        \end{tabular}

        % ==========================================================================
        \subsubsection{F\_KRN\_SERIAL\_PRN\_BYTE}
        \label{func:fkrnserialprnbyte}
        % ==========================================================================
        \begin{tabular}{l p{9cm}}
            \hline\textbf{Action}
            & Outputs a single hexadecimal byte in hexadecimal notation.\\
            \hline\textbf{Entry}
            & \texttt{A} = byte to output.\\
            \hline\textbf{Exit} & None \\
            \hline\textbf{Destroys} & \texttt{A} \\
            \hline\textbf{Calls}
            & \hyperref[func:fbiosserialconouta]{F\_BIOS\_SERIAL\_CONOUT\_A}\\
            \hline
        \end{tabular}

        % ==========================================================================
        \subsubsection{F\_KRN\_SERIAL\_PRN\_BYTES}
        \label{func:fkrnserialprnbytes}
        % ==========================================================================
        \begin{tabular}{l p{9cm}}
            \hline\textbf{Action}
            & Outputs \textit{n} number of bytes as ASCII characters.\\
            \hline\multirow[t]{2}{4em}{\textbf{Entry}}
            & \texttt{B} = number (\textit{n}) of bytes to output.\\
            & \texttt{HL} = address in \textbf{MEMORY} where the first byte to
            output is. \\
            \hline\textbf{Exit} & None \\
            \hline\textbf{Destroys} & \texttt{A}, \texttt{HL} \\
            \hline\textbf{Calls}
            & \hyperref[func:fbiosserialconouta]{F\_BIOS\_SERIAL\_CONOUT\_A}\\
            \hline
        \end{tabular}

        % ==========================================================================
        \subsubsection{F\_KRN\_SERIAL\_PRN\_WORD}
        \label{func:fkrnserialprnword}
        % ==========================================================================
        \begin{tabular}{l p{9cm}}
            \hline\textbf{Action}
            & Outputs the 4 hexadecimal digits of a word in hexadecimal notation.\\
            \hline\textbf{Entry}
            & \texttt{HL} = word to be output.\\
            \hline\textbf{Exit} & None \\
            \hline\textbf{Destroys} & \texttt{A} \\
            \hline\textbf{Calls}
            & \hyperref[func:fkrnserialprnbyte]{F\_KRN\_SERIAL\_PRN\_BYTE}\\
            \hline
        \end{tabular}

        % ==========================================================================
        \subsubsection{F\_KRN\_SERIAL\_BACKSPACE}
        \label{func:fkrnserialbackspace}
        % ==========================================================================
        \begin{tabular}{l p{9cm}}
            \hline\textbf{Action}
            & \\
            \hline\textbf{Entry}
            & \\
            \hline\textbf{Exit} &  \\
            \hline\textbf{Destroys} &  \\
            \hline\textbf{Calls}
            &  \\
            \hline
        \end{tabular}

        % ==========================================================================
        \subsubsection{F\_KRN\_SERIAL\_SEND\_ANSI\_CODE}
        \label{func:fkrnserialsendansicode}
        % ==========================================================================
        \begin{tabular}{l p{9cm}}
            \hline\textbf{Action}
            & Writes an ANSI code to the \textbf{SIO/2} Channel A. \\
            \hline\textbf{Entry}
            & \texttt{DE} = address in \textbf{MEMORY} where the first byte of
            ANSI escape code is.\\
            & \texttt{B} = number of bytes in the ANSI escape code.\\
            \hline\textbf{Exit} & None \\
            \hline\textbf{Destroys} & \texttt{A}, \texttt{DE} \\
            \hline\textbf{Calls}
            & \hyperref[func:fbiosserialconouta]{F\_BIOS\_SERIAL\_CONOUT\_A}\\
            \hline
        \end{tabular}

    % ==========================================================================
    \subsection{DZFS (file system) Routines}
    % ==========================================================================

        % ==========================================================================
        \subsubsection{F\_KRN\_DZFS\_READ\_SUPERBLOCK}
        \label{func:fkrndzfsreadsuperblock}
        % ==========================================================================
        \begin{tabular}{l p{9cm}}
            \hline\multirow[t]{2}{4em}{\textbf{Action}}
            & Reads 512 bytes from Sector 0 (corresponding to the DZFS 
            \textit{Superblock}) into the CF buffer in \textbf{MEMORY}.\\
            & If the \textit{Superblock} does not containe the correct DZFS
            signature, \texttt{CF\_is\_formatted} is set to 0x00. Otherwise, is
            set to 0x01.\\
            \hline\textbf{Entry} & None \\
            \hline\textbf{Exit} & None \\
            \hline\textbf{Destroys} & \texttt{A}, \texttt{BC}, \texttt{DE} \\
            \hline\textbf{Calls}
            & \hyperref[func:fbioscfreadsec]{F\_BIOS\_CF\_READ\_SEC}\\
            \hline
        \end{tabular}

        % ==========================================================================
        \subsubsection{F\_KRN\_DZFS\_READ\_BAT\_SECTOR}
        \label{func:fkrndzfsreadbatsector}
        % ==========================================================================
        \begin{tabular}{l p{9cm}}
            \hline\textbf{Action}
            & Reads a BAT Sector into \texttt{CF Card Buffer} in
            \textbf{MEMORY}.\\
            \hline\textbf{Entry} & \texttt{CF\_cur\_sector} holds the sector 
            number for the BAT.\\
            \hline\textbf{Exit} & \texttt{CF\ Card\ Buffer} contains the BAT sector.\\
            \hline\textbf{Destroys} & \texttt{BC}, \texttt{HL} \\
            \hline\textbf{Calls}
            & \hyperref[func:fbioscfreadsec]{F\_BIOS\_CF\_READ\_SEC}\\
            \hline
        \end{tabular}

        % ==========================================================================
        \subsubsection{F\_KRN\_DZFS\_BATENTRY\_TO\_BUFFER}
        \label{func:fkrndzfsbatentrytobuffer}
        % ==========================================================================
        \begin{tabular}{l p{9cm}}
            \hline\textbf{Action}
            & Extracts the data of a BAT entry from the \texttt{CF Card Buffer}
            in \textbf{MEMORY} and populates the values into System variables.\\
            \hline\textbf{Entry} & \texttt{A} = BAT entry to extract data from.\\
            \hline\textbf{Exit} & CF BAT System Variables are populated. See
            \hyperref[sec:ram_memmap]{RAM Memory Map} for for details.\\
            \hline\textbf{Destroys} & \texttt{A}, \texttt{BC}, \texttt{DE}, 
            \texttt{HL}, \texttt{IX}, \texttt{tmp\_addr1} \\
            \hline\textbf{Calls}
            & \hyperref[func:fkrnmultiply816slow]{F\_KRN\_MULTIPLY816\_SLOW}\\
            \hline
        \end{tabular}

        % ==========================================================================
        \subsubsection{F\_KRN\_DZFS\_SEC\_TO\_BUFFER}
        \label{func:fkrndzfssectobuffer}
        % ==========================================================================
        \begin{tabular}{l p{9cm}}
            \hline\textbf{Action}
            & Loads a Sector (512 bytes) from the \textbf{DISK} and copies the
            bytes into the \texttt{CF Card Buffer} in \textbf{MEMORY}.\\
            \hline\textbf{Entry} & \texttt{HL} = Sector number to load.\\
            \hline\textbf{Exit} & \texttt{CF\ Card\ Buffer} contains the bytes 
            of Sector loaded.\\
            \hline\textbf{Destroys} & \texttt{DE}, \texttt{HL} \\
            \hline\textbf{Calls}
            & \hyperref[func:fbioscfreadsec]{F\_BIOS\_CF\_READ\_SEC}\\
            \hline
        \end{tabular}

        % ==========================================================================
        \subsubsection{F\_KRN\_DZFS\_GET\_FILE\_BATENTRY}
        \label{func:fkrndzfsgetfilebatentry}
        % ==========================================================================
        \begin{tabular}{l p{9cm}}
            \hline\textbf{Action}
            & Gets the BAT's entry number of a specified filename.\\
            \hline\textbf{Entry} & \texttt{HL} = Address where the filename to 
            check is stored\\
            \hline\multirow[t]{2}{4em}{\textbf{Exit}}
            & BAT Entry values are stored in the SYSVARS.\\
            & \texttt{DE} = \$0000 if filename found. Otherwise, whatever value
            had at start.\\
            \hline\textbf{Destroys} & \texttt{A}, \texttt{DE}, \texttt{HL},
            \texttt{tmp\_addr2}, \texttt{tmp\_addr3} \\
            \hline\multirow[t]{4}{4em}{\textbf{Calls}}
            & \hyperref[func:fkrndzfsreadbatsector]{F\_KRN\_DZFS\_READ\_BAT\_SECTOR}\\
            & \hyperref[func:fkrndzfsbatentrytobuffer]{F\_KRN\_DZFS\_BATENTRY\_TO\_BUFFER}\\
            & \hyperref[func:fkrnstrlen]{F\_KRN\_STRLEN}\\
            & \hyperref[func:fkrnstrcmp]{F\_KRN\_STRCMP}\\
            \hline
        \end{tabular}

        % ==========================================================================
        \subsubsection{F\_KRN\_DZFS\_LOAD\_FILE\_TO\_RAM}
        \label{func:fkrndzfsloadfiletoram}
        % ==========================================================================
        \begin{tabular}{l p{9cm}}
            \hline\textbf{Action}
            & Load a file from \textbf{DISK}. Copies the bytes stored in the
            \textbf{DISK} into \textbf{MEMORY}, at the specified \textbf{MEMORY}
            address in the BAT.\\
            \hline\multirow[t]{2}{4em}{\textbf{Entry}}
            & \texttt{DE} = 1st sector number in the \textbf{DISK}.\\
            & \texttt{IX} = file length in sectors.\\
            \hline\textbf{Exit} & None\\
            \hline\textbf{Destroys} & \texttt{A}, \texttt{BC}, \texttt{DE},
            \texttt{HL}, \texttt{IX}, \texttt{tmp\_addr1}\\
            \hline\textbf{Calls}
            & \hyperref[func:fbioscfreadsec]{F\_BIOS\_CF\_READ\_SEC}\\
            \hline
        \end{tabular}

        % ==========================================================================
        \subsubsection{F\_KRN\_DZFS\_DELETE\_FILE}
        \label{func:fkrndzfsdeletefile}
        % ==========================================================================
        \begin{tabular}{l p{9cm}}
            \hline\textbf{Action}
            & Marks a file as deleted. The mark is done by changing the first
            character of the filename to 0x7E (~)\\
            \hline\textbf{Entry}
            & \texttt{DE} = BAT Entry number.\\
            \hline\textbf{Exit} & None\\
            \hline\textbf{Destroys} & \texttt{A}, \texttt{DE}, \texttt{HL},\\
            \hline\multirow[t]{2}{4em}{\textbf{Calls}}
            & \hyperref[func:fkrnmultiply816slow]{F\_KRN\_MULTIPLY816\_SLOW}\\
            & \hyperref[func:fkrndzfssectortocf]{F\_KRN\_DZFS\_SECTOR\_TO\_CF}\\
            \hline
        \end{tabular}

        % ==========================================================================
        \subsubsection{F\_KRN\_DZFS\_CHGATTR\_FILE}
        \label{func:fkrndzfschgattrfile}
        % ==========================================================================
        \begin{tabular}{l p{9cm}}
            \hline\textbf{Action}
            & Changes the attributes (RHSE) of a file.\\
            \hline\multirow[t]{2}{4em}{\textbf{Entry}}
            & \texttt{DE} = BAT Entry number.\\
            & \texttt{A} = attributes mask byte.\\
            \hline\textbf{Exit} & None\\
            \hline\textbf{Destroys} & \texttt{DE}, \texttt{HL},\\
            \hline\multirow[t]{2}{4em}{\textbf{Calls}}
            & \hyperref[func:fkrnmultiply816slow]{F\_KRN\_MULTIPLY816\_SLOW}\\
            & \hyperref[func:fkrndzfssectortocf]{F\_KRN\_DZFS\_SECTOR\_TO\_CF}\\
            \hline
        \end{tabular}

        % ==========================================================================
        \subsubsection{F\_KRN\_DZFS\_RENAME\_FILE}
        \label{func:fkrndzfsrenamefile}
        % ==========================================================================
        \begin{tabular}{l p{9cm}}
            \hline\textbf{Action}
            & Changes the name of a file.\\
            \hline\multirow[t]{2}{4em}{\textbf{Entry}}
            & \texttt{IY} = \textbf{MEMORY} address where the new filename is
            stored.\\
            & \texttt{DE} = BAT Entry number.\\
            \hline\textbf{Exit} & None\\
            \hline\textbf{Destroys} & \texttt{A}, \texttt{BC}, \texttt{DE},
            \texttt{HL}, \texttt{IY}\\
            \hline\multirow[t]{2}{4em}{\textbf{Calls}}
            & \hyperref[func:fkrnmultiply816slow]{F\_KRN\_MULTIPLY816\_SLOW}\\
            & \hyperref[func:fkrndzfssectortocf]{F\_KRN\_DZFS\_SECTOR\_TO\_CF}\\
            \hline
        \end{tabular}

        % ==========================================================================
        \subsubsection{F\_KRN\_DZFS\_FORMAT\_CF}
        \label{func:fkrndzfsformatcf}
        % ==========================================================================
        \begin{tabular}{l p{9cm}}
            \hline\textbf{Action}
            & Formats a \textbf{DISK} with DZFS.\\
            \hline\multirow[t]{2}{4em}{\textbf{Entry}}
            & \texttt{HL} = \textbf{MEMORY} address where the disk label is
            stored.\\
            & \texttt{DE} = \textbf{MEMORY} address where the number of 
            partitions is stored.\\
            \hline\textbf{Exit} & None\\
            \hline\textbf{Destroys} & \texttt{A}, \texttt{BC}, \texttt{DE},
            \texttt{HL}, \texttt{IX}, \texttt{IY}, \texttt{tmp\_addr1}\\
            \hline\multirow[t]{10}{4em}{\textbf{Calls}}
            & \hyperref[func:fkrnserialwrstr]{F\_KRN\_SERIAL\_WRSTR}\\
            & \hyperref[func:fkrndzfscalcsn]{F\_KRN\_DZFS\_CALC\_SN}\\
            & \hyperref[func:fbiosrtcgetdate]{F\_BIOS\_RTC\_GET\_DATE}\\
            & \hyperref[func:fbiosrtcgettime]{F\_BIOS\_RTC\_GET\_TIME}\\
            & \hyperref[func:fkrnbcdtoascii]{F\_KRN\_BCD\_TO\_ASCII}\\
            & \hyperref[func:fkrnbintobcd4]{F\_KRN\_BIN\_TO\_BCD4}\\
            & \hyperref[func:fkrnbintobcd6]{F\_KRN\_BIN\_TO\_BCD6}\\
            & \hyperref[func:fkrndzfssectortocf]{F\_KRN\_DZFS\_SECTOR\_TO\_CF}\\
            & \hyperref[func:fkrnsetmemrng]{F\_KRN\_SETMEMRNG}\\
            & \hyperref[func:fbiosserialconouta]{F\_BIOS\_SERIAL\_CONOUT\_A}\\
            \hline
        \end{tabular}

        % ==========================================================================
        \subsubsection{F\_KRN\_DZFS\_CALC\_SN}
        \label{func:fkrndzfscalcsn}
        % ==========================================================================
        \begin{tabular}{l p{9cm}}
            \hline\textbf{Action}
            & Calculates the Serial Number (4 bytes) for a \textbf{DISK}.\\
            \hline\textbf{Entry}
            & \texttt{IX} = \textbf{MEMORY} address where the serial number will
            be stored.\\
            \hline\textbf{Exit} & None\\
            \hline\textbf{Destroys} & \texttt{A}, \texttt{BC}, \texttt{DE},
            \texttt{HL}, \texttt{IX} \\
            \hline\multirow[t]{3}{4em}{\textbf{Calls}}
            & \hyperref[func:fbiosrtcgetdate]{F\_BIOS\_RTC\_GET\_DATE}\\
            & \hyperref[func:fbiosrtcgettime]{F\_BIOS\_RTC\_GET\_TIME}\\
            & \hyperref[func:fkrnmultiply816slow]{F\_KRN\_MULTIPLY816\_SLOW}\\
            \hline
        \end{tabular}

        % ==========================================================================
        \subsubsection{F\_KRN\_DZFS\_SECTOR\_TO\_CF}
        \label{func:fkrndzfssectortocf}
        % ==========================================================================
        \begin{tabular}{l p{9cm}}
            \hline\textbf{Action}
            & Calls the \textbf{BIOS} subroutine that will store the data 
            (512 bytes) currently in CF Card Buffer in \textbf{MEMORY}, to the
            \textbf{DISK}.\\
            \hline\textbf{Entry}
            & \texttt{CF\_cur\_sector} = the sector number in the \textbf{DISK}
            that will be written.\\
            \hline\textbf{Exit} & None\\
            \hline\textbf{Destroys} & \texttt{BC}, \texttt{DE}\\
            \hline\textbf{Calls}
            & \hyperref[func:fbioscfwritesec]{F\_BIOS\_CF\_WRITE\_SEC}\\
            \hline
        \end{tabular}

        % ==========================================================================
        \subsubsection{F\_KRN\_DZFS\_GET\_BAT\_FREE\_ENTRY}
        \label{func:fkrndzfsgetbatfreeentry}
        % ==========================================================================
        \begin{tabular}{l p{9cm}}
            \hline\textbf{Action}
            & Get number of available BAT entry.\\
            \hline\textbf{Entry} & None\\
            \hline\textbf{Exit} & \texttt{CF\_cur\_file\_entry\_number} = entry 
            number.\\
            \hline\textbf{Destroys} & \texttt{A}, \texttt{IY},
            \texttt{CF\_cur\_sector}, \texttt{CF\_cur\_file\_entry\_number}\\
            \hline\multirow[t]{2}{4em}{\textbf{Calls}}
            & \hyperref[func:fkrndzfsreadbatsector]{F\_KRN\_DZFS\_READ\_BAT\_SECTOR}\\
            & \hyperref[func:fkrndzfsbatentrytobuffer]{F\_KRN\_DZFS\_BATENTRY\_TO\_BUFFER}\\
            \hline
        \end{tabular}

        % ==========================================================================
        \subsubsection{F\_KRN\_DZFS\_ADD\_BAT\_ENTRY}
        \label{func:fkrndzfsaddbatentry}
        % ==========================================================================
        \begin{tabular}{l p{9cm}}
            \hline\textbf{Action}
            & Adds a BAT entry into the \textbf{DISK}.\\
            \hline\multirow[t]{4}{4em}{\textbf{Entry}}
            & \texttt{DE} = BAT entry number.\\
            & \texttt{CF\_cur\_sector} = Sector number where the BAT Entry is in
            the \textbf{DISK}.\\
            & \texttt{CF Buffer} = Sector (512 bytes) containing the BAT where
            the entry is.\\
            & \texttt{CF BAT} = BAT Entry data that will be saved to 
            \textbf{DISK}.\\
            \hline\textbf{Exit} & None\\
            \hline\textbf{Destroys} & \texttt{A}, \texttt{BC}, \texttt{DE}, 
            \texttt{HL}\\
            \hline\textbf{Calls}
            & \hyperref[func:fkrnmultiply816slow]{F\_KRN\_MULTIPLY816\_SLOW}\\
            \hline
        \end{tabular}

        % ==========================================================================
        \subsubsection{F\_KRN\_DZFS\_CREATE\_NEW\_FILE}
        \label{func:fkrndzfscreatenewfile}
        % ==========================================================================
        \begin{tabular}{l p{9cm}}
            \hline\textbf{Action}
            & Creates a new file (and its corresponding BAT Entry) in the 
            \textbf{DISK}, from bytes stored in \textbf{MEMORY}.\\
            \hline\multirow[t]{3}{4em}{\textbf{Entry}}
            & \texttt{HL} = \textbf{MEMORY} address of the first byte to be
            stored.\\
            & \texttt{BC} = number of bytes to be stored in the \textbf{DISK}.\\
            & \texttt{IX} = \textbf{MEMORY} address where the filename is
            stored.\\
            \hline\textbf{Exit} & None\\
            \hline\textbf{Destroys} & \texttt{A}, \texttt{BC}, \texttt{DE}, 
            \texttt{HL}, \texttt{IX}, \texttt{tmp\_addr1}, \texttt{tmp\_addr2},
            \texttt{tmp\_addr3}, \texttt{tmp\_byte}\\
            \hline\multirow[t]{11}{4em}{\textbf{Calls}}
            & \hyperref[func:fkrndzfsgetbatfreeentry]{F\_KRN\_DZFS\_GET\_BAT\_FREE\_ENTRY}\\
            & \hyperref[func:fkrndiv1616]{F\_KRN\_DIV1616}\\
            & \hyperref[func:fkrnmultiply1616]{F\_KRN\_MULTIPLY1616}\\
            & \hyperref[func:fkrncopymem512]{F\_KRN\_COPYMEM512}\\
            & \hyperref[func:fkrnclearcfbuffer]{F\_KRN\_CLEAR\_CFBUFFER}\\
            & \hyperref[func:fkrndzfssectortocf]{F\_KRN\_DZFS\_SECTOR\_TO\_CF}\\
            & \hyperref[func:fkrndzfscalcfiletime]{F\_KRN\_DZFS\_CALC\_FILETIME}\\
            & \hyperref[func:fkrndzfscalcfiledate]{F\_KRN\_DZFS\_CALC\_FILEDATE}\\
            & \hyperref[func:fkrndzfssectobuffer]{F\_KRN\_DZFS\_SEC\_TO\_BUFFER}\\
            & \hyperref[func:fkrndzfssectobuffer]{F\_KRN\_DZFS\_ADD\_BAT\_ENTRY}\\
            & \hyperref[func:fkrndzfssectortocf]{F\_KRN\_DZFS\_SECTOR\_TO\_CF}\\
            \hline
        \end{tabular}

        % ==========================================================================
        \subsubsection{F\_KRN\_DZFS\_CALC\_FILETIME}
        \label{func:fkrndzfscalcfiletime}
        % ==========================================================================
        \begin{tabular}{l p{9cm}}
            \hline\multirow[t]{2}{4em}{\textbf{Action}}
            & Packs current Real-Time Clock time into two bytes, which is the
            format used to store times (created/modified) for files in the 
            \textbf{DISK}.\\
            & The formula used is: $2048 * hours + 32 * minutes + seconds / 2$\\
            \hline\textbf{Entry} & None\\
            \hline\textbf{Exit} & \texttt{HL} = RTC time\\
            \hline\textbf{Destroys} & \texttt{A}, \texttt{DE}, \texttt{HL}\\
            \hline\textbf{Calls}
            & \hyperref[func:fbiosrtcgettime]{F\_BIOS\_RTC\_GET\_TIME}\\
            \hline
        \end{tabular}

        % ==========================================================================
        \subsubsection{F\_KRN\_DZFS\_CALC\_FILEDATE}
        \label{func:fkrndzfscalcfiledate}
        % ==========================================================================
        \begin{tabular}{l p{9cm}}
            \hline\multirow[t]{2}{4em}{\textbf{Action}}
            & Packs current Real-Time Clock date into two bytes, which is the
            format used to store dates (created/modified) for files in the 
            \textbf{DISK}.\\
            & The formula used is: $512 * (year - 2000) + month * 32 + day$\\
            \hline\textbf{Entry} & None\\
            \hline\textbf{Exit} & \texttt{HL} = RTC date\\
            \hline\textbf{Destroys} & \texttt{A}, \texttt{DE}, \texttt{HL}\\
            \hline\textbf{Calls}
            & \hyperref[func:fbiosrtcgetdate]{F\_BIOS\_RTC\_GET\_DATE}\\
            \hline
        \end{tabular}

        % ==========================================================================
        \subsubsection{F\_KRN\_DZFS\_SHOW\_DISKINFO\_SHORT}
        \label{func:fkrndzfsshowdiskinfoshort}
        % ==========================================================================
        \begin{tabular}{l p{9cm}}
            \hline\textbf{Action}
            & Outputs to the \textbf{CONSOLE} some information of the 
            \textbf{DISK}: volume label, serial number, date/time creation.\\
            \hline\textbf{Entry} & None\\
            \hline\textbf{Exit} & None\\
            \hline\textbf{Destroys} & \texttt{A}, \texttt{BC}, \texttt{DE}, 
            \texttt{HL}\\
            \hline\multirow[t]{5}{4em}{\textbf{Calls}}
            & \hyperref[func:fkrnserialwrstrclr]{F\_KRN\_SERIAL\_WRSTRCLR}\\
            & \hyperref[func:fkrnserialprnbyte]{F\_KRN\_SERIAL\_PRN\_BYTE}\\
            & \hyperref[func:fkrnserialprnbytes]{F\_KRN\_SERIAL\_PRN\_BYTES}\\
            & \hyperref[func:fbiosserialconouta]{F\_BIOS\_SERIAL\_CONOUT\_A}\\
            & \hyperref[func:fkrnserialemptylines]{F\_KRN\_SERIAL\_EMPTYLINES}\\
            \hline
        \end{tabular}

        % ==========================================================================
        \subsubsection{F\_KRN\_DZFS\_SHOW\_DISKINFO}
        \label{func:fkrndzfsshowdiskinfo}
        % ==========================================================================
        \begin{tabular}{l p{9cm}}
            \hline\textbf{Action}
            & Outputs to the \textbf{CONSOLE} all information of the 
            \textbf{DISK}: volume label, serial number, date/time creation,
            file system ID, number of partitions, number of bytes per sector,
            number of sectors per block.\\
            \hline\textbf{Entry} & None\\
            \hline\textbf{Exit} & None\\
            \hline\textbf{Destroys} & \texttt{A}, \texttt{BC}, \texttt{DE}, 
            \texttt{HL}\\
            \hline\multirow[t]{5}{4em}{\textbf{Calls}}
            & \hyperref[func:fkrnserialwrstrclr]{F\_KRN\_SERIAL\_WRSTRCLR}\\
            & \hyperref[func:fkrnserialprnbyte]{F\_KRN\_SERIAL\_PRN\_BYTE}\\
            & \hyperref[func:fkrnserialprnbytes]{F\_KRN\_SERIAL\_PRN\_BYTES}\\
            & \hyperref[func:fbiosserialconouta]{F\_BIOS\_SERIAL\_CONOUT\_A}\\
            & \hyperref[func:fkrnserialemptylines]{F\_KRN\_SERIAL\_EMPTYLINES}\\
            \hline
        \end{tabular}

        % ==========================================================================
        \subsubsection{F\_KRN\_DZFS\_CHECK\_FILE\_EXISTS}
        \label{func:fkrndzfscheckfileexists}
        % ==========================================================================
        \begin{tabular}{l p{9cm}}
            \hline\textbf{Action}
            & Checks if a specified filename exsists in the \textbf{DISK}.\\
            \hline\textbf{Entry} & \texttt{HL} = \textbf{MEMORY} address where
            the filename to check is stored.\\
            \hline\textbf{Exit} & \texttt{Z Flag} set if filename is not found.\\
            \hline\textbf{Destroys} & \texttt{A}, \texttt{DE},
            \texttt{tmp\_addr3}\\
            \hline\textbf{Calls}
            & \hyperref[func:fkrndzfsgetfilebatentry]{F\_KRN\_DZFS\_GET\_FILE\_BATENTRY}\\
            \hline
        \end{tabular}

    % ==========================================================================
    \subsection{Math Routines}
    % ==========================================================================

        % ==========================================================================
        \subsubsection{F\_KRN\_MULTIPLY816\_SLOW}
        \label{func:fkrnmultiply816slow}
        % ==========================================================================
        \begin{tabular}{l p{9cm}}
            \hline\multirow[t]{2}{4em}{\textbf{Action}}
            & Multiplies an 8-bit number by a 16-bit number (HL = A * DE).\\
            & It does a slow multiplication by adding the multiplier to itself
            as many times as multiplicand (e.g. 8 * 4 = 8+8+8+8).\\
            \hline\multirow[t]{2}{4em}{\textbf{Entry}}
            & \texttt{A} = Multiplicand\\
            & \texttt{DE} = Multiplier\\
            \hline\textbf{Exit} & \texttt{HL} = Product \\
            \hline\textbf{Destroys} & \texttt{B}, \texttt{HL} \\
            \hline\textbf{Calls} & None\\
            \hline
        \end{tabular}

        % ==========================================================================
        \subsubsection{F\_KRN\_MULTIPLY1616}
        \label{func:fkrnmultiply1616}
        % ==========================================================================
        \begin{tabular}{l p{9cm}}
            \hline\textbf{Action}
            & Multiplies two 16-bit numbers (HL = HL * DE)\\
            \hline\multirow[t]{2}{4em}{\textbf{Entry}}
            & \texttt{HL} = Multiplicand\\
            & \texttt{DE} = Multiplier\\
            \hline\textbf{Exit} & \texttt{HL} = Product \\
            \hline\textbf{Destroys} & \texttt{A}, \texttt{BC}, \texttt{DE}, \texttt{HL} \\
            \hline\textbf{Calls} & None\\
            \hline
        \end{tabular}

        % ==========================================================================
        \subsubsection{F\_KRN\_DIV1616}
        \label{func:fkrndiv1616}
        % ==========================================================================
        \begin{tabular}{l p{9cm}}
            \hline\textbf{Action}
            & Divides two 16-bit numbers (BC = BC / DE, HL = remainder)\\
            \hline\multirow[t]{2}{4em}{\textbf{Entry}}
            & \texttt{BC} = Dividend\\
            & \texttt{DE} = Divisor\\
            \hline\multirow[t]{2}{4em}{\textbf{Exit}}
            & \texttt{BC} = Quotient\\
            & \texttt{HL} = Remainder\\
            \hline\textbf{Destroys} & \texttt{A}, \texttt{BC}, \texttt{HL} \\
            \hline\textbf{Calls} & None\\
            \hline
        \end{tabular}

        % ==========================================================================
        \subsubsection{F\_KRN\_CRC16\_INI}
        \label{func:fkrncrc16ini}
        % ==========================================================================
        \begin{tabular}{l p{9cm}}
            \hline\textbf{Action}
            & Initialises the CRC to 0 and the polynomial to the appropriate bit
            pattern, to generate a CRC-16/BUYPASS1\footnote{A 16-bit cyclic redundancy
            check (CRC) based on the IBM Binary Synchronous Communications
            protocol (BSC or Bisync). It uses the polynomial
            $X^{16} + X^{15} +X^2 + 1$}.\\
            \hline\textbf{Entry} & None \\
            \hline\multirow[t]{2}{4em}{\textbf{Exit}}
            & \texttt{MATH\_CRC} = 0 (initial CRC value)\\
            & \texttt{MATH\_polynomial} = CRC polynomial\\
            \hline\textbf{Destroys} & \texttt{HL} \\
            \hline\textbf{Calls} & None\\
            \hline
        \end{tabular}

        % ==========================================================================
        \subsubsection{F\_KRN\_CRC16\_GEN}
        \label{func:fkrncrc16gen}
        % ==========================================================================
        \begin{tabular}{l p{9cm}}
            \hline\textbf{Action}
            & Combines the previous CRC with the CRC generated from the current
            data byte, to generate a CRC-16/BUYPASS1\footnote{A 16-bit cyclic
            redundancy check (CRC) based on the IBM Binary Synchronous 
            Communications protocol (BSC or Bisync). It uses the polynomial
            $X^{16} + X^{15} +X^2 + 1$}.\\
            \hline\multirow[t]{3}{4em}{\textbf{Entry}}
            & \texttt{A} = current data byte.\\
            & \texttt{MATH\_CRC} = previous CRC\\
            & \texttt{MATH\_polynomial} = CRC polynomial\\
            \hline\textbf{Exit}
            & \texttt{MATH\_CRC} = CRC with current data byte included\\
            \hline\textbf{Destroys} & \texttt{A}, \texttt{BC}, \texttt{DE}, \texttt{HL} \\
            \hline\textbf{Calls} & None\\
            \hline
        \end{tabular}

    % ==========================================================================
    \subsection{String manipulation Routines}
    % ==========================================================================

        % ==========================================================================
        \subsubsection{F\_KRN\_IS\_PRINTABLE}
        \label{func:fkrnisprintable}
        % ==========================================================================
        \begin{tabular}{l p{9cm}}
            \hline\textbf{Action}
            & Checks if a character is a printable ASCII character.\\
            \hline\textbf{Entry} & \texttt{A} = character to check.\\
            \hline\textbf{Exit} & \texttt{C Flag} is set if character is printable.\\
            \hline\textbf{Destroys} & None\\
            \hline\textbf{Calls} & None\\
            \hline
        \end{tabular}

        % ==========================================================================
        \subsubsection{F\_KRN\_IS\_NUMERIC}
        \label{func:fkrnisnumeric}
        % ==========================================================================
        \begin{tabular}{l p{9cm}}
            \hline\textbf{Action}
            & Checks if a character is numeric (0, 1, 2, 3, 4, 5, 6, 7, 8 or 9).\\
            \hline\textbf{Entry} & \texttt{A} = character to check.\\
            \hline\textbf{Exit} & \texttt{C Flag} is set if character is numeric.\\
            \hline\textbf{Destroys} & None\\
            \hline\textbf{Calls} & None\\
            \hline
        \end{tabular}

        % ==========================================================================
        \subsubsection{F\_KRN\_TOUPPER}
        \label{func:fkrntoupper}
        % ==========================================================================
        \begin{tabular}{l p{9cm}}
            \hline\textbf{Action}
            & Converts a charcater to uppercase (e.g. \textit{a} is converted to
            \texttt{A}).\\
            \hline\textbf{Entry} & \texttt{A} = character to convert.\\
            \hline\textbf{Exit} & \texttt{A} = uppercased character.\\
            \hline\textbf{Destroys} & None\\
            \hline\textbf{Calls} & None\\
            \hline
        \end{tabular}

        % ==========================================================================
        \subsubsection{F\_KRN\_STRCMP}
        \label{func:fkrnstrcmp}
        % ==========================================================================
        \begin{tabular}{l p{9cm}}
            \hline\textbf{Action}
            & Compares two strings.\\
            \hline\multirow[t]{4}{4em}{\textbf{Entry}}
            & \texttt{A} = length of string 1.\\
            & \texttt{HL} = \textbf{MEMORY} address where the first byte of
            string 1 is located.\\
            & \texttt{B} = length of string 2.\\
            & \texttt{DE} = \textbf{MEMORY} address where the first byte of
            string 2 is located.\\
            \hline\multirow[t]{4}{4em}{\textbf{Exit}}
            & if str1 = str 2, \texttt{Z Flag} set and \texttt{C Flag} not set.\\
            & if str1 != str 2 and str1 longer than str2, \texttt{Z Flag} not 
            set and \texttt{C Flag} not set.\\
            & if str1 != str 2 and str1 shorter than str2, \texttt{Z Flag} not 
            set and \texttt{C Flag} set.\\
            \hline\textbf{Destroys} & \texttt{A}, \texttt{BC}, \texttt{DE},\texttt{HL} \\
            \hline\textbf{Calls} & None\\
            \hline
        \end{tabular}

        % ==========================================================================
        \subsubsection{F\_KRN\_STRCPY}
        \label{func:fkrnstrcpy}
        % ==========================================================================
        \begin{tabular}{l p{9cm}}
            \hline\textbf{Action}
            & Copies \textit{n} characters from string 1 to string 2.\\
            \hline\multirow[t]{3}{4em}{\textbf{Entry}}
            & \texttt{HL} = \textbf{MEMORY} address where the first byte of
            string 1 is located.\\
            & \texttt{DE} = \textbf{MEMORY} address where the first byte of
            string 2 is located.\\
            & \texttt{B} = number of characters to copy.\\
            \hline\textbf{Exit} & None\\
            \hline\textbf{Destroys} & \texttt{A}, \texttt{DE}, \texttt{HL}\\
            \hline\textbf{Calls} & None\\
            \hline
        \end{tabular}

        % ==========================================================================
        \subsubsection{F\_KRN\_STRLEN}
        \label{func:fkrnstrlen}
        % ==========================================================================
        \begin{tabular}{l p{9cm}}
            \hline\textbf{Action}
            & Gets the length of a string that is terminated with a specified
            character.\\
            \hline\multirow[t]{2}{4em}{\textbf{Entry}}
            & \texttt{HL} = \textbf{MEMORY} address where the first byte of the
            string is located.\\
            & \texttt{A} = terminating character.\\
            \hline\textbf{Exit} & \texttt{B} = lenght of the string.\\
            \hline\textbf{Destroys} & \texttt{BC}, \texttt{HL}\\
            \hline\textbf{Calls} & None\\
            \hline
        \end{tabular}

    % ==========================================================================
    \subsection{Conversion Routines}
    % ==========================================================================

        % ==========================================================================
        \subsubsection{F\_KRN\_ASCIIADR\_TO\_HEX}
        \label{func:fkrnasciiadrtohex}
        % ==========================================================================
        \begin{tabular}{l p{9cm}}
            \hline\textbf{Action}
            & Convert an address (or any 2 bytes) from hex ASCII to its 
            hexadecimal value (e.g. 32 35 37 30 are converted into 2570).\\
            \hline\textbf{Entry} & \texttt{IX} = \textbf{MEMORY} address where
            the first byte is located.\\
            \hline\textbf{Exit} & \texttt{HL} = hexadecimal converted value.\\
            \hline\textbf{Destroys} & \texttt{HL}\\
            \hline\textbf{Calls}
            & \hyperref[func:fkrnasciitohex]{F\_KRN\_ASCII\_TO\_HEX}\\
            \hline
        \end{tabular}

        % ==========================================================================
        \subsubsection{F\_KRN\_ASCII\_TO\_HEX}
        \label{func:fkrnasciiadrtohex}
        % ==========================================================================
        \begin{tabular}{l p{9cm}}
            \hline\textbf{Action}
            & Converts two ASCII characters (representing two hexadecimal digits)
            ; to one byte in hexadecimal (e.g. 0x33 and 0x45 are converted into
            3E).\\
            \hline\multirow[t]{2}{4em}{\textbf{Entry}}
            & \texttt{H} = Most significant ASCII digit.\\
            & \texttt{L} = Less significant ASCII digit.\\
            \hline\textbf{Exit} & \texttt{A} = Converted value.\\
            \hline\textbf{Destroys} & \texttt{A}, \texttt{BC}\\
            \hline\textbf{Calls} & None\\
            \hline
        \end{tabular}

        % ==========================================================================
        \subsubsection{F\_KRN\_HEX\_TO\_ASCII}
        \label{func:fkrnhextoasciiadr}
        % ==========================================================================
        \begin{tabular}{l p{9cm}}
            \hline\textbf{Action}
            & Converts one byte in hexadecimal to two ASCII printable characters
            (e.g. 0x3E is converted into 33 and 45, which are the ASCII values
            of 3 and E).\\
            \hline\textbf{Entry} & \texttt{A} = Byte to convert.\\
            \hline\multirow[t]{2}{4em}{\textbf{Exit}}
            & \texttt{H} = Most significant ASCII digit.\\
            & \texttt{L} = Less significant ASCII digit.\\
            \hline\textbf{Destroys} & \texttt{A}, \texttt{BC}, \texttt{HL}\\
            \hline\textbf{Calls} & None\\
            \hline
        \end{tabular}

        % ==========================================================================
        \subsubsection{F\_KRN\_BIN\_TO\_BCD4}
        \label{func:fkrnbintobcd4}
        % ==========================================================================
        \begin{tabular}{l p{9cm}}
            \hline\textbf{Action}
            & Converts a byte of unsigned integer hexadecimal to 4-digit BCD
            (e.g. 0x80 is converted into 0128).\\
            \hline\textbf{Entry} & \texttt{A} = Unsigned integer to convert.\\
            \hline\multirow[t]{2}{4em}{\textbf{Exit}}
            & \texttt{H} = Hundreds digits.\\
            & \texttt{L} = Tens digits.\\
            \hline\textbf{Destroys} & \texttt{A}, \texttt{BC}, \texttt{HL}\\
            \hline\textbf{Calls} & None\\
            \hline
        \end{tabular}

        % ==========================================================================
        \subsubsection{F\_KRN\_BIN\_TO\_BCD6}
        \label{func:fkrnbintobcd6}
        % ==========================================================================
        \begin{tabular}{l p{9cm}}
            \hline\textbf{Action}
            & Converts two bytes of unsigned integer hexadecimal to 6-digit BCD
            (e.g. 0xFFFF is converted into 065535).\\
            \hline\textbf{Entry} & \texttt{HL} = Unsigned integer to convert.\\
            \hline\multirow[t]{3}{4em}{\textbf{Exit}}
            & \texttt{C} = Thousands digits.\\
            & \texttt{D} = Hundreds digits.\\
            & \texttt{E} = Tens digits.\\
            \hline\textbf{Destroys} & \texttt{A}, \texttt{BC}, \texttt{DE}, \texttt{HL}\\
            \hline\textbf{Calls} & None\\
            \hline
        \end{tabular}

        % ==========================================================================
        \subsubsection{F\_KRN\_BCD\_TO\_ASCII}
        \label{func:fkrnbcdtoascii}
        % ==========================================================================
        \begin{tabular}{l p{9cm}}
            \hline\textbf{Action}
            & Converts 6-digit BCD to hexadecimal ASCII string
            (e.g. 512 is converted into 30 30 30 35 31 32).\\
            \hline\multirow[t]{4}{4em}{\textbf{Entry}}
            & \texttt{DE} = \textbf{MEMORY} address where the converted string
            will be stored.\\
            & \texttt{C} = first two digits of the 6-digit BCD to convert.\\
            & \texttt{H} = next two digits of the 6-digit BCD to convert.\\
            & \texttt{L} = last two digits of the 6-digit BCD to convert.\\
            \hline\textbf{Exit} & None\\
            \hline\textbf{Destroys} & \texttt{A}, \texttt{DE}\\
            \hline\textbf{Calls} & None\\
            \hline
        \end{tabular}

        % ==========================================================================
        \subsubsection{F\_KRN\_BITEXTRACT}
        \label{func:fkrnbitextract}
        % ==========================================================================
        \begin{tabular}{l p{9cm}}
            \hline\textbf{Action}
            & Extracts a group of bits from a byte and returns the group in the
            LSB position.\\
            \hline\multirow[t]{3}{4em}{\textbf{Entry}}
            & \texttt{E} = byte from where to extract bits.\\
            & \texttt{D} = number of bits to extract.\\
            & \texttt{A} = start extraction at bit number.\\
            \hline\textbf{Exit} & \texttt{A} = extracted group of bits\\
            \hline\textbf{Destroys} & \texttt{A}, \texttt{BC}, \texttt{DE}, 
            \texttt{HL}\\
            \hline\textbf{Calls} & None\\
            \hline
        \end{tabular}

        % ==========================================================================
        \subsubsection{F\_KRN\_BIN\_TO\_ASCII}
        \label{func:fkrnbintoascii}
        % ==========================================================================
        \begin{tabular}{l p{9cm}}
            \hline\textbf{Action}
            & Converts a 16-bit signed binary number (-32768 to 32767) to ASCII
            data (e.g. 32767 is converted into 33 32 37 36 37).\\
            \hline\multirow[t]{2}{4em}{\textbf{Entry}}
            & \texttt{D} = High byte of value to convert.\\
            & \texttt{E} = Low byte of value to convert.\\
            \hline\textbf{Exit} & \texttt{CLI\_buffer\_pgm} = converted ASCII data.
            First byte us the length.\\
            \hline\textbf{Destroys} & \texttt{A}, \texttt{BC}, \texttt{DE}, 
            \texttt{HL}, \texttt{CLI\_buffer\_pgm}\\
            \hline\textbf{Calls} & None\\
            \hline
        \end{tabular}

        % ==========================================================================
        \subsubsection{F\_KRN\_DEC\_TO\_BIN}
        \label{func:fkrndectobin}
        % ==========================================================================
        \begin{tabular}{l p{9cm}}
            \hline\textbf{Action}
            & Converts an ASCII string consisting of the length of the number
            (in bytes), a possible ASCII - or + sign, and a series of ASCII
            digits to two bytes of binary data. Note that the length is an
            ordinary binary number, not an ASCII number. (e.g. 33 32 37 36 37 is
            converted into 7FFF).\\
            \hline\textbf{Entry} & \texttt{HL} = \textbf{MEMORY} address where
            the string to be converted is.\\
            \hline\textbf{Exit} & \texttt{HL} = converted bytes.\\
            \hline\textbf{Destroys} & \texttt{A}, \texttt{BC}, \texttt{DE}, 
            \texttt{HL}, \texttt{tmp\_byte}\\
            \hline\textbf{Calls} & None\\
            \hline
        \end{tabular}

        % ==========================================================================
        \subsubsection{F\_KRN\_PKEDDATE\_TO\_DMY}
        \label{func:fkrnpkeddatetodmy}
        % ==========================================================================
        \begin{tabular}{l p{9cm}}
            \hline\textbf{Action}
            & Extracts day, month and year from a packed date (used by DZFS to
            store dates).\\
            \hline\textbf{Entry} & \texttt{HL} = packed date.\\
            \hline\multirow[t]{3}{4em}{\textbf{Exit}}
            & \texttt{A} = day.\\
            & \texttt{B} = month.\\
            & \texttt{C} = year.\\
            \hline\textbf{Destroys} & \texttt{A}, \texttt{BC}, \texttt{HL},
            \texttt{tmp\_addr1}\\
            \hline\textbf{Calls} & None\\
            \hline
        \end{tabular}

        % ==========================================================================
        \subsubsection{F\_KRN\_PKEDTIME\_TO\_HMS}
        \label{func:fkrnpkedtimetohms}
        % ==========================================================================
        \begin{tabular}{l p{9cm}}
            \hline\textbf{Action}
            & Extracts hour, minutes and seconds from a packed time (used by
            DZFS to store times).\\
            \hline\textbf{Entry} & \texttt{HL} = packed time.\\
            \hline\multirow[t]{3}{4em}{\textbf{Exit}}
            & \texttt{A} = hour.\\
            & \texttt{B} = minutes.\\
            & \texttt{C} = seconds.\\
            \hline\textbf{Destroys} & \texttt{A}, \texttt{BC}, \texttt{HL},
            \texttt{tmp\_addr1}\\
            \hline\textbf{Calls} & None\\
            \hline
        \end{tabular}

    % ==========================================================================
    \subsection{MEMORY Routines}
    % ==========================================================================

        % ==========================================================================
        \subsubsection{F\_KRN\_SETMEMRNG}
        \label{func:fkrnsetmemrng}
        % ==========================================================================
        \begin{tabular}{l p{9cm}}
            \hline\textbf{Action}
            & Sets (changes) a value in a \textbf{MEMORY} position range.\\
            \hline\multirow[t]{3}{4em}{\textbf{Entry}}
            & \texttt{HL} = \textbf{MEMORY} start position (first byte).\\
            & \texttt{BC} = number of bytes to set.\\
            & \texttt{A} = value to set.\\
            \hline\textbf{Exit} & None\\
            \hline\textbf{Destroys} & \texttt{BC}, \texttt{HL}\\
            \hline\textbf{Calls} & None\\
            \hline
        \end{tabular}

        % ==========================================================================
        \subsubsection{F\_KRN\_COPYMEM512}
        \label{func:fkrncopymem512}
        % ==========================================================================
        \begin{tabular}{l p{9cm}}
            \hline\textbf{Action}
            & Copies bytes from one area of \textbf{MEMORY} to another, in group
            of 512 bytes (i.e. max. 512 bytes). If less than 512 bytes are to be
            copied, the rest will be filled with zeros.\\
            \hline\multirow[t]{3}{4em}{\textbf{Entry}}
            & \texttt{HL} = \textbf{MEMORY} origin position (from where to copy
            the bytes).\\
            & \texttt{DE} = \textbf{MEMORY} destination position (to where to
            copy the bytes).\\
            & \texttt{BC} = number of bytes to copy (MUST be less or equal to
            512).\\
            \hline\textbf{Exit} & None\\
            \hline\textbf{Destroys} & \texttt{A}, \texttt{BC}, \texttt{DE},
            \texttt{HL}\\
            \hline\textbf{Calls} & None\\
            \hline
        \end{tabular}

        % ==========================================================================
        \subsubsection{F\_KRN\_SHIFT\_BYTES\_BY1}
        \label{func:fkrnshiftbytesby1}
        % ==========================================================================
        \begin{tabular}{l p{9cm}}
            \hline\textbf{Action}
            & Moves bytes (by one) to the right and replaces first byte with
            bytes counter.\\
            \hline\multirow[t]{2}{4em}{\textbf{Entry}}
            & \texttt{HL} = \textbf{MEMORY} address of last byte to move.\\
            & \texttt{BC} = number of bytes to move.\\
            \hline\textbf{Exit} & None\\
            \hline\textbf{Destroys} & \texttt{A}, \texttt{DE}, \texttt{HL}\\
            \hline\textbf{Calls} & None\\
            \hline
        \end{tabular}

        % ==========================================================================
        \subsubsection{F\_KRN\_CLEAR\_MEMAREA}
        \label{func:fkrnclearmemarea}
        % ==========================================================================
        \begin{tabular}{l p{9cm}}
            \hline\textbf{Action}
            & Clears (with zeros) a number of bytes, starting at a specified
            \textbf{MEMORY} address. Maximum 256 bytes can be cleared.\\
            \hline\multirow[t]{2}{4em}{\textbf{Entry}}
            & \texttt{IX} = \textbf{MEMORY} address of first byte to clear.\\
            & \texttt{B} = number of bytes to clear.\\
            \hline\textbf{Exit} & None\\
            \hline\textbf{Destroys} & \texttt{A}, \texttt{BC}, \texttt{IX}\\
            \hline\textbf{Calls} & None\\
            \hline
        \end{tabular}

        % ==========================================================================
        \subsubsection{F\_KRN\_CLEAR\_CFBUFFER}
        \label{func:fkrnclearcfbuffer}
        % ==========================================================================
        \begin{tabular}{l p{9cm}}
            \hline\textbf{Action}
            & Clears (with zeros) the \textbf{MEMORY} area of the \textbf{DISK}
            buffer.\\
            \hline\textbf{Entry} & None\\
            \hline\textbf{Exit} & None\\
            \hline\textbf{Destroys} & \texttt{BC}, \texttt{IX}\\
            \hline\textbf{Calls} & \hyperref[func:fkrnclearmemarea]{F\_KRN\_CLEAR\_MEMAREA}\\
            \hline
        \end{tabular}

    \pagebreak
    % ==========================================================================
    \section{dastaZ80 File System (DZFS)}
    % ==========================================================================
    In summary, a file system is a layer of abstraction to store, retrieve and
    update a set of files.

    A file system manages access to the data and the metadata of the files, and
    manages the available space of the device, dividing the storage area into
    units of storage and keeping a map of every storage unit of the device.
    
    DZFS main goal is to be very simple to implement. As the free
    \textbf{MEMORY} (i.e. \textbf{RAM} - OS - System variables and buffers) of
    the dastaZ80 is about 55,952 bytes, it makes no sense to have files bigger
    than that, as will not fit. Therefore, DZFS defines that \textit{a Block can
    store only a single file}.

    dastaZ80 access the \textbf{DISK} via Logical Block Addressing (LBA), which
    is a particularly simple linear addressing schema, in which each sector is
    assigned a unique number rather than referring to a cylinder, head, and
    sector (CHS) to access the disk.
    
    A typical LBA scheme uses a 28-bit value that allows up to 8.4 GB of data
    storage capacity. DZFS schema is as follows:

    \begin{tabular}{ c c c c }
        \hline
        LBA 3 & LBA 2 & LBA 1 & LBA 0\\
        \hline
        0000 & 0000 00PP & BBBB BBBB & BBSS SSSS\\
        \hline
    \end{tabular}

    Where:

    \begin{itemize}
        \item S is Sector (6 bits)
        \item B is Block (10 bits)
        \item P is Partition (2 bits)
        \item 0 not used (10 bits)
    \end{itemize}

    % ==========================================================================
    \subsection{DZFS characteristics}
    % ==========================================================================

    \begin{itemize}
        \item \textbf{Bytes per Sector}: 512
        \item \textbf{Sectors per Block}: 64
        \item \textbf{Bytes per Block}: 32,768 (64 * 512). This also defines the
        maximum size of a file and the BAT maximum size.
        \item \textbf{Bytes per BAT entry}: 32
        \item \textbf{BAT entries}: 1024 (32,768 / 32). This also defines the 
        maximum number of files per Partition.
        \item \textbf{Blocks per Partition}: 1,024 (1 reserved for BAT)
        \item \textbf{Sectors per Partition}: 65,536 (1,024 * 64)
        \item \textbf{Bytes per Partition}: 33,587,200 (1,024 * 32,768 + 1 BAT Block)
        \item \textbf{Partitions per Disk}: 3 (125 MB1) / 33,587,200)
    \end{itemize}

    % ==========================================================================
    \subsection{DISK anatomy}
    % ==========================================================================

    A disk (128 MB CompactFlash in our case) is divided into areas:

    \begin{itemize}
        \item \textbf{Superblock} = 512 bytes
        \item \textbf{Partition 1}
        \begin{itemize}
            \item \textbf{Block Allocation Table (BAT)} = 1 Block
            \item \textbf{Data Area} = 1023 Blocks
        \end{itemize}
        \item \textbf{Partition 2}
        \begin{itemize}
            \item \textbf{Block Allocation Table (BAT)} = 1 Block
            \item \textbf{Data Area} = 1023 Blocks
        \end{itemize}
        \item \textbf{Partition 3}
        \begin{itemize}
            \item \textbf{Block Allocation Table (BAT)} = 1 Block
            \item \textbf{Data Area} = 1023 Blocks
        \end{itemize}
    \end{itemize}

        % ==========================================================================
        \subsubsection{Superblock}
        % ==========================================================================
        The first 512 bytes on the \textbf{DISK} contain fundamental information
        about the geometry, and is used by the OS to know how to access every
        other information on the \textbf{DISK}. On IBM PC-compatibles, this is
        known as the \textit{Master Boot Record} or \textit{MBR} for short. In
        DZFS, it is called \textit{Superblock}, as it is an orphan sector that
        doesn't belong to any block.

        \begin{longtable}{ |m{2.2cm}|m{1.3cm}|m{6cm}|m{2.7cm}| }
            \hline
            \rowcolor{lightgray}
            Offset & Length (bytes) & Description & Example\\
            \hline
            \endfirsthead

            \hline
            \rowcolor{lightgray}
            Offset & Length (bytes) & Description & Example\\
            \hline
            \endhead

            0x00 & 2 & Signature. Used to check that this is a Superblock. Set
            to 0xABBA & \texttt{AB BA}\\
            \hline
            0x02 & 1 & Not used & \texttt{00}\\
            \hline
            0x03 & 8 & File system identifier. ASCII values for human-readable.
            Padded with spaces. & \texttt{DZFSV1}\\
            \hline
            0x0B & 4 & Volume serial number & \texttt{35 2A 15 F2}\\
            \hline
            0x0F & 1 & Not used. & \texttt{00}\\
            \hline
            0x10 & 16 & Volume Label. ASCII values. Padded with spaces. 
            & \texttt{dastaZ80 Main}\\
            \hline
            0x20 & 8 & Volume Date creation. ASCII values (ddmmyyyy).
            & \texttt{03102022}\\
            \hline
            0x28 & 6 & Volume Time creation. ASCII values (hhmmss).
            & \texttt{142232}\\
            \hline
            0x2E & 2 & Bytes per Sector (in Hexadecimal little-endian)
            & \texttt{00 02}\\
            \hline
            0x30 & 1 & Sectors per Block (in Hexadecimal) & \texttt{40}\\
            \hline
            0x31 & 1 & Number of Partitions & \texttt{01}\\
            \hline
            0x32 - 0x64 & 51 & Copyright notice (ASCII value)
            & \texttt{Copyright 2022David Asta The MIT License (MIT)}\\
            \hline
            0x65 - 0x1FF & 411 & Not used (filled with 0x00)
            & \texttt{00 00 00 00 00 00 00 .........}\\
            \hline
        \end{longtable}


        % ==========================================================================
        \subsubsection{Block Allocation Table (BAT)}
        % ==========================================================================
        The BAT is an area of 32 bytes on the \textbf{DISK} used to store the 
        details about the files saved in the Data Area, and is comprised of file
        descriptors called \textit{entry}. Each entry holds information about a
        single file.

        For simplicity, each entry works also as index. The first entry 
        describes the first file on the \textbf{DISK}, the second entry 
        describes the second file, and so on. 

        \begin{longtable}{ |m{1cm}|m{1.3cm}|m{6.8cm}|m{2.7cm}| }
            \hline
            \rowcolor{lightgray}
            Offset & Length (bytes) & Description & Example\\
            \hline
            \endfirsthead

            \hline
            \rowcolor{lightgray}
            Offset & Length (bytes) & Description & Example\\
            \hline
            \endhead

            \multirow{4}{4em}{0x00} & \multirow{4}{4em}{14} & \textbf{Filename}
            & \texttt{46 49 4C 45 30 30 30 30 31 20 20 20 20 20}\\
            & & Padded with spaces at the end. &\\
            & & (only allowed A to Z and 0 to 9. No spaces allowed. Cannot start
            with a number.) &\\
            & & First character also indicates 00=available, 7E=deleted (will
            appear as ~) &\\
            \hline
            \multirow{6}{4em}{0x0E} & \multirow{6}{4em}{14} & \textbf{Attributes} (0=Inactive / 1=Active) 
            & Read Only, System file, Executable = 1101 = \texttt{0D}\\
            & & Bit 0 = Read Only &\\
            & & Bit 1 = Hidden &\\
            & & Bit 2 = System &\\
            & & Bit 3 = Executable &\\
            & & Bit 4-7 = Not used &\\
            \hline
            \multirow{4}{4em}{0x0F} & \multirow{4}{4em}{2} & \textbf{Time created}
            & \texttt{F5 9A}\\
            & & 5 bits for hour (binary number 0-23) &\\
            & & 6 bits for minutes (binary number 0-59) &\\
            & & 5 bits for seconds (binary number seconds / 2) &\\
            \hline
            \multirow{4}{4em}{0x11} & \multirow{4}{4em}{2} & \textbf{Date created}
            & \texttt{69 1B}\\
            & & 7 bits for year since 2000 (max. is year 2127) &\\
            & & 4 bits for month (binary number 0-12) &\\
            & & 5 bits for day (binary number 0-31) &\\
            \hline
            0x13 & 2 & Time last modified (same formula as Time created) 
            & \texttt{F5 9A}\\
            \hline
            0x15 & 2 & Date last modified (same formula as Date created)
            & \texttt{69 1B}\\
            \hline
            0x17 & 2 & File size in bytes (little-endian) & \texttt{26 00}\\
            \hline
            0x19 & 1 & File size in sectors (little-endian) & \texttt{01}\\
            \hline
            0x1A & 2 & Entry number (little-endian) & \texttt{00 00}\\
            \hline
            \multirow{2}{4em}{0x1C} & \multirow{2}{4em}{2} & \textbf{1st Sector} (where the file data starts)
            & \texttt{41 00}\\
            & & It is calculated when the file is created. The formula is: 65 + 
            64 * entry\_number &\\
            \hline
            0x1E & 2 & Load address (The start address little-endian where it 
            will be loaded in RAM) & \texttt{68 25}\\
            \hline
        \end{longtable}

        % ==========================================================================
        \subsubsection{Data Area}
        % ==========================================================================
        The Data Area is the area of the \textbf{DISK} used to store file data 
        (e.g. programs, documents).
        
        It is divided into Blocks of 64 Sectors each.

    \pagebreak
    % ==========================================================================
    \section{How To}
    % ==========================================================================

    % ==========================================================================
    \subsection{Read data from DISK}
    % ==========================================================================
    Given \texttt{CF\_is\_formatted} is equal to 0xFF (i.e. \textbf{DISK} is 
    formatted with DZFS file system), call \hyperref[func:fkrndzfsloadfiletoram]{F\_KRN\_DZFS\_LOAD\_FILE\_TO\_RAM}
    with \texttt{DE} equal to first sector (512 bytes) to read and \texttt{IX}
    equal to how many sectors to read.

    Read bytes will be copied into \textbf{MEMORY}, starting at the address 
    equal to the address stored at \texttt{CF\_cur\_file\_load\_addr} which is
    stored in the Block Allocation Table (BAT) in \textbf{DISK}.

    % ==========================================================================
    \subsection{Write data to DISK}
    % ==========================================================================
    Given \texttt{CF\_is\_formatted} is equal to 0xFF (i.e. \textbf{DISK} is
    formatted with DZFS file system):

    \begin{itemize}
        \item Store the filename (in ASCII) somewhere in \texttt{MEMORY}.
        \item call \hyperref[func:fkrndzfsgetfilebatentry]{F\_KRN\_DZFS\_GET\_FILE\_BATENTRY},
            with \texttt{HL} equal to the \texttt{MEMORY} address where the
            filename is stored. If a file with the specified filename does not
            exist, flag \texttt{z} will be set, therefore it is OK to save the
            file.
        \item call \hyperref[func:func:fkrndzfscreatenewfile]{F\_KRN\_DZFS\_CREATE\_NEW\_FILE},
            with \texttt{HL} equal to the address in \textbf{MEMORY} of first
            byte to be stored, \texttt{BC} equal to the total number of bytes to
            be stored, and \texttt{IX} equal to the address in \textbf{MEMORY}
            where the filename is stored.
    \end{itemize}

    \pagebreak
    % ==========================================================================
    \section{Appendixes}
    % ==========================================================================
    \label{sec:appendixes}

    % ==========================================================================
    \subsection{ANSI Terminal colours}
    % ==========================================================================

    \begin{itemize}
        \item ANSI\_COLR\_BLK - Black
        \item ANSI\_COLR\_RED - {\color{red}Red}
        \item ANSI\_COLR\_GRN - {\color{green}Green}
        \item ANSI\_COLR\_YLW - {\color{yellow}Yellow}
        \item ANSI\_COLR\_BLU - {\color{blue}Blue}
        \item ANSI\_COLR\_MGT - {\color{magenta}Magenta}
        \item ANSI\_COLR\_CYA - {\color{cyan}Cyan}
        \item ANSI\_COLR\_WHT -
        \item ANSI\_COLR\_GRY - {\color{gray}Grey}
    \end{itemize}

    % ==========================================================================
    \subsection{How DZFS Volume Serial Number is calculated}
    % ==========================================================================
    Calculated by combining the date and time at the point of format:

    \begin{itemize}
        \item first byte is calculated as follows:
        \begin{itemize}
            \item day + miliseconds (converted to hexadecimal)
            \item e.g. 3 + 50 = 53 (0x35)
        \end{itemize}
        \item second byte is calculated as follows:
        \begin{itemize}
            \item month + seconds (converted to hexadecimal)
            \item e.g. 10 + 32 = 42 (0x2A)
        \end{itemize}
        \item last two bytes are calculated as follows:
        \begin{itemize}
            \item (hours [if pm + 12] * 256) + minutes + year (converted to hexadecimal)
            \item e.g. (2 + 12 = 14 * 256 = 3584) + 22 + 2012 = 5618 (0x15 0xF2)
        \end{itemize}
    \end{itemize}

    % ==========================================================================
    \subsection{OS Boot Sequence}
    % ==========================================================================
    After power on or after pressing the \textbf{RESET} button:

    \begin{itemize}
        \item \textbf{Bootstrap}
        \begin{itemize}
            \item Copy contents of the ROM into High RAM (0x8000 - 0xFFFF).
            \item Disable ROM chip and enable Low RAM (0x0000 - 0x7FFF). Therefore, all \textbf{MEMORY} is RAM from now on.
            \item Copy the copy of ROM inm High RAM to Low RAM. Bootstrap code is not copied.
            \item Transfer control to BIOS (\texttt{jp F\_BIOS\_SERIAL\_INIT})
        \end{itemize}
        \item \textbf{Initialise SIO/2}
        \begin{itemize}
            \item Initialise SIO/2
            \begin{itemize}
                \item Set Channel A as 115,000 bps, 8N1, Interrupt in all 
                received characters.
                \item Set Channel B as 115,000 bps, 8N1, Interrupt in all 
                received characters.
                \item Set Interrupt Vector to 0x60.
            \end{itemize}
            \item Set CPU to Interrupt Mode 2.
            \item \texttt{jp F\_BIOS\_WBOOT}
        \end{itemize}
        \item \textbf{BIOS Boot}
        \begin{itemize}
            \item Set SIO/2 Channel A as primary I/O.
            \item Transfer control to Kernel ()\texttt{jp F\_KRN\_START}).
        \end{itemize}
        \item \textbf{Kernel Boot}
        \begin{itemize}
            \item Display dzOS welcome message.
            \item Display dzOS release version.
            \item Display Kernel version.
            \item Display available RAM.
            \item Initialise CompactFlash Card.
            \item Display volume ID, Serial Number and date/time of format.
            \item Detect Real-Time Clock (RTC).
            \item Display RTC's battery status.
            \item Transfer control to Command-line Interpreter (CLI) ()\texttt{jp F\_CLI\_START}).
        \end{itemize}
        \item \textbf{CLI}
        \begin{itemize}
            \item Display CLI version.
            \item Clear command buffers
            \item Display prompt (>).
            \item Read command entered by user.
            \item Parse command.
            \item Execute command.
            \item Loop back to Display prompt.
        \end{itemize}
    \end{itemize}
\end{document}