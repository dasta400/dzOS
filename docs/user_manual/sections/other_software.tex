% ==========================================================================
\section{Other Software}
% ==========================================================================

    % ======================================================================
    \subsection{Memory Dump (memdump)}
    % ======================================================================
    \label{software:memdump}

    This program shows the contents (bytes) of a specified range of
    \textbf{MEMORY}.

    The contents are printed as hexadecimal bytes, in groups of 16 per each line
    and with the printable ASCII value (if printable) or just a dot (if not
    printable).

    At the start of the program, the user will be asked to enter the
    \textit{Start Address} and the \textit{End Address}. In the case of leaving
    blank (i.e. just press the \textit{Return} key without entering any value),
    the program will terminate.

    Example for \textit{Start Address} = 0B40 and \textit{End Address} = 0BEF:

    \texttt{
    \resizebox{12cm}{!}{
        \begin{tabular}{l l l l l l l l l l l l l l l l l l}
                    & 00 & 01 & 02 & 03 & 04 & 05 & 06 & 07 & 08 & 09 & 0A & 0B & 0C & 0D & 0E & 0F   & \\
            \cline{2-17}
            0B40: & FF & FF & FF & FF & FF & FF & FF & FF & FF & FF & FF & FF & FF & FF & FF & 00   & ................\\
            0B50: & 21 & 3A & 0F & CD & BE & 03 & 06 & 01 & CD & 20 & 04 & CD & 4D & 0C & 21 & 56   & !:.......\ ..M.!V\\
            0B60: & 0F & CD & BE & 03 & 21 & C4 & 22 & 3E & 00 & 32 & C4 & 22 & CD & 75 & 0B & CD   & ....!.">.2.".u..\\
            0B70: & B1 & 0B & C3 & 5B & 0B & CD & C8 & 03 & FE & 20 & CA & 91 & 0B & FE & 2C & CA   & ...$[$.....\ ....,.\\
            0B80: & 91 & 0B & FE & 0D & CA & B0 & 0B & 77 & 23 & C3 & 75 & 0B & C9 & 2B & C3 & 75   & .......w\#.u..+.u\\
            0B90: & 0B & 3A & E4 & 22 & FE & 00 & CA & A4 & 0B & 3A & 04 & 23 & FE & 00 & CA & AA   & .:.".....:.\#....\\
            0BA0: & 0B & C3 & 75 & 0B & 21 & E4 & 22 & C3 & 75 & 0B & 21 & 04 & 23 & C3 & 75 & 0B   & ..u.!.".u.!.\#.u.\\
            0BB0: & C9 & 21 & C4 & 22 & 7E & FE & 00 & CA & 5B & 0B & 11 & 29 & 14 & CD & 02 & 0C   & .!."~...$[$..$)$....\\
            0BC0: & CA & 89 & 0E & 11 & 10 & 14 & CD & 02 & 0C & CA & 93 & 0E & 11 & 2C & 14 & CD   & .............,..\\
            0BD0: & 02 & 0C & CA & 55 & 0E & 11 & 25 & 14 & CD & 02 & 0C & CA & 15 & 0F & 11 & 15   & ...U..\%.........\\
            0BE0: & 14 & CD & 02 & 0C & CA & 9A & 0E & 11 & 1A & 14 & CD & 02 & 0C & CA & C7 & 0E   & ................
        \end{tabular}
    }}

    If the information reaches the bottom of the screen, a message will be shown
    to let the user decide what to do next:

    \hspace{1cm}\texttt{[SPACE] for more or another key to stop}

    % ======================================================================
    \subsection{Video Memory Dump (vramdump)}
    % ======================================================================
    \label{software:vramdump}

    This program shows the contents (bytes) of a specified range
    of \textbf{VRAM}.

    The contents are printed as hexadecimal bytes, in groups of 16 per each
    line.

    At the start of the program, the user will be asked to enter the
    \textit{Start Address} and the \textit{End Address}. In the case of leaving
    blank (i.e. just press the \textit{Return} key without entering any value),
    the program will terminate.

    Example for \textit{Start Address} = 0000 and \textit{End Address} = 00AF:

    \texttt{
    \resizebox{12cm}{!}{
        \begin{tabular}{l l l l l l l l l l l l l l l l l l}
                    & 00 & 01 & 02 & 03 & 04 & 05 & 06 & 07 & 08 & 09 & 0A & 0B & 0C & 0D & 0E & 0F   & \\
            \cline{2-17}
            0000: & 00 & 00 & 00 & 00 & 00 & 00 & 00 & 00 & FF & FF & FF & FF & FF & FF & FF & FF\\
            0010: & 00 & 00 & 00 & 00 & 00 & 01 & 03 & 07 & 00 & 00 & 00 & 00 & 00 & 80 & C0 & E0\\
            0020: & 07 & 03 & 01 & 00 & 00 & 00 & 00 & 00 & E0 & C0 & 80 & 00 & 00 & 00 & 00 & 00\\
            0030: & F0 & F0 & F0 & F0 & 00 & 00 & 00 & 00 & F0 & F8 & FC & FE & FF & FF & FF & FF\\
            0040: & 0F & 1F & 3F & 7F & FF & FF & FF & FF & FF & FF & FF & FF & FE & FC & F8 & F0\\
            0050: & FF & FF & FF & FF & 7F & 3F & 1F & 0F & 00 & 00 & 00 & 00 & 00 & 00 & 00 & 00\\
            0060: & 0B & C3 & 75 & 0B & 21 & E4 & 22 & C3 & 75 & 0B & 21 & 04 & 23 & C3 & 75 & 0B\\
            0070: & C9 & 21 & C4 & 22 & 7E & FE & 00 & CA & 5B & 0B & 11 & 29 & 14 & CD & 02 & 0C\\
            0080: & CA & 89 & 0E & 11 & 10 & 14 & CD & 02 & 0C & CA & 93 & 0E & 11 & 2C & 14 & CD\\
            0090: & 02 & 0C & CA & 55 & 0E & 11 & 25 & 14 & CD & 02 & 0C & CA & 15 & 0F & 11 & 15\\
            00A0: & 14 & CD & 02 & 0C & CA & 9A & 0E & 11 & 1A & 14 & CD & 02 & 0C & CA & C7 & 0E
        \end{tabular}
    }}

    If the information reaches the bottom of the screen, a message will be shown
    to let the user decide what to do next:

    \hspace{1cm}\texttt{[SPACE] for more or another key to stop}

    % ======================================================================
    \subsection{Load Screen dumps (loadscr)}
    % ======================================================================
    \label{sub:loadscr}
    This program loads screen dumps, saved as raw data, to the the VRAM. It is
    in essence a picture display program.

    In Mode 2 (Graphics II Mode bitmapped), screen data dumps are files of
    14,336 bytes in length, composed by:
    \begin{itemize}
        \item Dump of the Pattern Table (6,144 bytes)
        \item Dump of the Sprite Pattern Table (2,048 bytes) filled with zeros
        \item Dump of the Colour Table (6,144 bytes)
    \end{itemize}

    In dzOS, these files are identified as File Type \textit{SC1}
    (Graphics I Mode), \textit{SC2} (Graphics II Bitmapped Mode) and
    \textit{SC3} (Multicolour Mode).

    % ======================================================================
    \subsection{Load Font (loadfont)}
    % ======================================================================
    \label{sub:loadfont}

    This program loads font files, which contain pattern definitions for text
    characters to be used for text display.

    Mode 0 (Text Mode) uses 6x8 bytes characters. The rest of the modes use 8x8
    bytes characters.

    In dzOS, these files are identified as File Type \textit{FN6} and
    \textit{FN8} respectively.

    % ==========================================================================
    \subsection{Machine Language Monitor (mlmonitor)}
    % ==========================================================================
    \label{software:mlmonitor}

    The Machine Language Monitor contains many features that will enable you to
    create, modfy and test machine language program and subroutines.

    It allows to assemble code into memory, disassemble memory, inspect memory,
    save memory into disk, and more.

    Once loaded, the monitor program will display a prompt in the form of a
    single dot.

    At this prompt, the user can enter any of the available commands presented
    below. Just bear in mind that all commands, addresses and bytes MUST be
    entered using capital letters. It is highly recommended to activate the
    \textit{Caps Lock} key during the usage of the monitor program.

    Also, all addresses and bytes MUST be entered in hexadecimal notation.

        % ==========================================================================
        \subsubsection{A - Assemble}
        % ==========================================================================

        Purpose: Assemble a line of assembly code.

        Syntax: A \textit{$<$address$>$ $<$mnemonic$>$ $<$operand$>$}

        Example: \texttt{A 2000 LD A,(HL)}

        \hspace{1cm}\textit{$<$address$>$}: a four-digit hexadecimal number indicating
        the location in memory where to place the generated opcode.

        \hspace{1cm}\textit{$<$mnemonic$>$}: a valid Z80 assembly language
        mnemonic (e.g. LD, ADD, CALL, LDIR).

        \hspace{1cm}\textit{$<$operand$>$}: the operand of the mnemonic.

        For a complete list of valid Z80 mnemonics and its operands check the
        \textit{Z80 Family CPU User Manual}\cite{z80manual}, publiched by ZiLOG.

        % ==========================================================================
        \subsubsection{C - Call}
        % ==========================================================================

        Purpose: Transfers the Program Counter (PC) of the Z80 to the specified
        address. Hence, the \textbf{CPU} starts executing the code it finds at
        the specified address. Works same as the \hyperref[cmd:run]{run} command.

        Syntax: C \textit{$<$address$>$}

        Example: \texttt{C 4000}

        \hspace{1cm}\textit{$<$address$>$}: a four-digit hexadecimal number
        indicating the location in \textbf{RAM} memory of the byte that will be
        displayed.

        \textbf{IMPORTANT}: In order for the \hyperref[software:mlmonitor]
        {Machine Language Monitor} to continue to work after the called
        subroutine ends, the subroutine MUST end with a return (\textit{RET})
        instruction. mlmonitor already takes care of putting in the Stack the
        current address before changing the Program Counter (PC).

        % ==========================================================================
        \subsubsection{D - Disassemble}
        % ==========================================================================

        Purpose: Disassemble machine code into assembly language mnemonics and
        operands.

        Syntax: D \textit{$<$start\_address$>$ $<$end\_address$>$}

        Example: \texttt{D 2000 210A}

        \hspace{1cm}\textit{$<$start\_address$>$}: a four-digit hexadecimal
        number indicating the location in memory of the first byte to
        disassemble.

        \hspace{1cm}\textit{$<$end\_address$>$}: a four-digit hexadecimal
        number indicating the location in memory of the last byte to
        disassemble.

        % ==========================================================================
        \subsubsection{E - Enter program in Hexadecimal}
        % ==========================================================================

        Purpose:  Allows to enter Hexadecimal values (e.g. obtained from an
        assembled program) into memory. It's an \textit{easy} way to test
        programs.

        Syntax: E \textit{$<$start\_address$>$}

        Example: \texttt{E 2000}

        \hspace{1cm}\textit{$<$start\_address$>$}: a four-digit hexadecimal
        number indicating the location in memory of the first address to which
        hexadecimal values will be inserted.

        After entering the command, the ML monitor shows the current value at
        that address ($<$start\_address$>$) and allows the user to enter a new
        value (1 byte). After the user enters a value and presses ENTER, the
        next address and value will be shown and the process will repeat.
        To exit (and not change the last value), just press ENTER without
        entering any value.

        % ==========================================================================
        \subsubsection{F - Fill memory}
        % ==========================================================================

        Purpose: Fill a range of locations with a specified byte.

        Syntax: F \textit{$<$start\_address$>$ $<$end\_address$>$ $<$byte$>$}

        Example: \texttt{F 2000 2100 FF}

        \hspace{1cm}\textit{$<$start\_address$>$}: a four-digit hexadecimal
        number indicating the location in memory of the first byte to
        disassemble.

        \hspace{1cm}\textit{$<$end\_address$>$}: a four-digit hexadecimal
        number indicating the location in memory of the last byte to
        disassemble.

        \hspace{1cm}\textit{$<$byte$>$}: the byte value that will be used to
        fill the locations in memory.

        % ==========================================================================
        \subsubsection{L - Load from disk}
        % ==========================================================================

        Purpose: Load a filename from \textbf{DISK} into \textbf{RAM} memory.
        Works similar to the \hyperref[cmd:load]{load} command, with the
        difference that here a load address MUST be specified.

        Syntax: L \textit{$<$load\_address$>$ $<$filename$>$}

        Example: \texttt{L 2000 testfile}

        \hspace{1cm}\textit{$<$load\_address$>$}: a four-digit hexadecimal
        number indicating the location in memory where the bytes from the
        filename will start to be stored.

        \hspace{1cm}\textit{$<$filename$>$}: an existing filename stored in the
        current \textbf{DISK}.

        % ==========================================================================
        \subsubsection{M - Display RAM memory}
        % ==========================================================================

        Purpose: Display \textbf{RAM} memory as a hexadecimal dump. Works same
        as the \hyperref[software:memdump]{memdump} program.

        Syntax: M \textit{$<$start\_address$>$ $<$end\_address$>$}

        Example: \texttt{M 2000 2100}

        \hspace{1cm}\textit{$<$start\_address$>$}: a four-digit hexadecimal
        number indicating the location in \textbf{RAM} memory of the first byte
        to display.

        \hspace{1cm}\textit{$<$end\_address$>$}: a four-digit hexadecimal
        number indicating the location in \textbf{RAM} memory of the last byte
        to display.

        % ==========================================================================
        \subsubsection{P - poke}
        % ==========================================================================

        Purpose: Modify a single \textbf{RAM} memory address with a specified
        value. Works same as the \hyperref[cmd:poke]{poke} command.

        Syntax: P \textit{$<$address$>$ $<$byte$>$}

        Example: \texttt{P 8000 AB}

        \hspace{1cm}\textit{$<$address$>$}: a four-digit hexadecimal number
        indicating the location in \textbf{RAM} memory of the byte that will be
        modified.

        \hspace{1cm}\textit{$<$byte$>$}: the byte value that will be used to
        modify the location in \textbf{RAM} memory.

        % ==========================================================================
        \subsubsection{Q - vpoke}
        % ==========================================================================

        Purpose: Modify a single video \textbf{VDP} memory address with a
        specified value. Works same as the \hyperref[cmd:vpoke]{vpoke} command.

        Syntax: Q \textit{$<$address$>$ $<$byte$>$}

        Example: \texttt{Q 0800 AB}

        \hspace{1cm}\textit{$<$address$>$}: a four-digit hexadecimal number
        indicating the location in video \textbf{VDP} memory of the byte that
        will be modified.

        \hspace{1cm}\textit{$<$byte$>$}: the byte value that will be used to
        modify the location in video \textbf{VDP} memory.

        % ==========================================================================
        \subsubsection{S - Save to disk}
        % ==========================================================================

        Purpose: Save the contents of memory to a filename in \textbf{DISK}.

        Syntax: S \textit{$<$start\_address$>$ $<$end\_address$>$ $<$filename$>$}

        Example: \texttt{S 2000 2100 testfile}

        \hspace{1cm}\textit{$<$start\_address$>$}: a four-digit hexadecimal
        number indicating the location in \textbf{RAM} memory of the first byte
        that will be saved to \textbf{DISK}.

        \hspace{1cm}\textit{$<$end\_address$>$}: a four-digit hexadecimal
        number indicating the location in \textbf{RAM} memory of the last byte
        that will be saved to \textbf{DISK}.

        \hspace{1cm}\textit{$<$filename$>$}: a non-existing filename in the
        current \textbf{DISK}.

        % ==========================================================================
        \subsubsection{T - Transfer memory area}
        % ==========================================================================

        Purpose: Transfer segments of \textbf{RAM} memory from one memory area
        to another.

        Syntax: T \textit{$<$start\_address$>$ $<$end\_address$>$
        $<$start\_destination\_address$>$}

        Example: \texttt{T 2000 2100 8000}

        \hspace{1cm}\textit{$<$start\_address$>$}: a four-digit hexadecimal
        number indicating the location in \textbf{RAM} memory of the first byte
        that will be transferred.

        \hspace{1cm}\textit{$<$start\_address$>$}: a four-digit hexadecimal
        number indicating the location in \textbf{RAM} memory of the last byte
        that will be transferred.

        \hspace{1cm}\textit{$<$start\_destination\_address$>$}: a four-digit
        hexadecimal number indicating the location in \textbf{RAM} memory of the
        first byte that will receive the transferred bytes.

        % ==========================================================================
        \subsubsection{V - Display Video RAM memory}
        % ==========================================================================

        Purpose: Display video \textbf{VDP} memory as a hexadecimal dump. Works
        same as the \hyperref[software:vramdump]{vramdump} program.

        Syntax: V \textit{$<$start\_address$>$ $<$end\_address$>$}

        Example: \texttt{V 2000 2100}

        \hspace{1cm}\textit{$<$start\_address$>$}: a four-digit hexadecimal
        number indicating the location in video \textbf{VDP} memory of the first
        byte to display.

        \hspace{1cm}\textit{$<$end\_address$>$}: a four-digit hexadecimal
        number indicating the location in video \textbf{VDP} memory of the last
        byte to display.

        % ==========================================================================
        \subsubsection{X - Exit to OS}
        % ==========================================================================

        Purpose: Terminates the \hyperref[software:mlmonitor]
        {Machine Language Monitor} and goes back to the Operating System's
        Command-Line Interface (\textbf{CLI}).

        Syntax: X

        Example: \texttt{X}

        % ==========================================================================
        \subsubsection{Y - peek}
        % ==========================================================================

        Purpose: Display the value from a \textbf{RAM} memory address. Works
        same as the \hyperref[cmd:peek]{peek} command.

        Syntax: Y \textit{$<$address$>$}

        Example: \texttt{Y 4000}

        \hspace{1cm}\textit{$<$address$>$}: a four-digit hexadecimal number
        indicating the location in \textbf{RAM} memory of the byte that will be
        displayed.

        % ==========================================================================
        \subsubsection{Z - vpeek}
        % ==========================================================================

        Purpose: Display the value from a video \textbf{VDP} memory address.
        % Works same as the \hyperref[cmd:vpeek]{vpeek} command.

        Syntax: Z \textit{$<$address$>$}

        Example: \texttt{Z 0800}

        \hspace{1cm}\textit{$<$address$>$}: a four-digit hexadecimal number
        indicating the location in video \textbf{VDP} memory of the byte that
        will be displayed.

    % ======================================================================
    \subsection{Paste File to RAM (pastefile)}
    % ======================================================================
    \label{software:pastefile}

    Allows to transfer files via a Terminal Emulator software (like Minicom or
    PuTTY), directly into the \textbf{RAM} of the dastaZ80. It's very handy for
    testing new software under
    development.

    The computer MUST be set to \hyperref[subsec:devmode]{Developer Mode}.

    The program MUST be run with two parameters:

    \begin{itemize}
        \item RAM address where received bytes will start to be copied.
        \item Total number of bytes to receive, in hexadecimal 4 digits notation.
    \end{itemize}

    For example, lets imagine we have assembled in our Linux PC a program and
    we are connected to the dastaZ80 with Minicom. The binary of our assembled
    program has a size of 145 bytes (\texttt{0x0091}) and the start address is
    \texttt{0x4420}

    First we need to get the hexadecimal values of the assembled binary. There
    are multiple tools to do this, but from Linux command line we can get it
    with \texttt{xxd -p -c 256}. \textit{-p} outputs the bytes as plain text.
    \textit{-c 256} prints 256 (the max. we can) bytes per line. Copy the text
    to the clipboard (typically Ctrl + C). Be sure there are no spaces between
    the bytes. This will happen if there are more than 256 bytes.

    Next, we run pastefile in dastaZ80: \texttt{pastefile 4420 0091}

    Then we paste the bytes into the terminal program, and pastefile will
    receive and write them into \textbf{RAM}.

    It is \textbf{important} to remember that you MUST set a character delay of
    1ms in your terminal software\footnote{In Minicom, press Ctrl + A and then
    T. The \textit{Terminal settings} will be displayed. Press F, enter a 1 and
    press ENTER twice.}. Otherwise some bytes will be lost, though
    dastaZ80 will not be aware. And when you run the program there will be very
    unexpected results.

    % % ==========================================================================
    % \subsection{Logo}
    % % ==========================================================================
    % Logo is an educational programming language, designed in 1967 by Wally
    % Feurzeig, Seymour Papert, and Cynthia Solomon, at Bolt, Beranek and Newman
    % (BBN), a Cambridge, Massachusetts research firm.

    % Logo's most-know feature is the turtle\footnote{Turtles are a class of
    % educational robots designed originally in the late 1940s and used in
    % computer science and mechanical engineering training.}, an on-screen
    % cursor-like that shows output from commands for movement and a small
    % retractable pen, together producing line graphics.

    % Taking advantage of the dual video output capabilities of the dastaZ80, in
    % this implementation of Logo commands are entered by the user in the
    % \textbf{High Resolution Display}, while graphics are shown fullscreen in
    % the \textbf{Low Resolution Display}, using Graphics Mode II (256x192 pixels).

    % Due to a limitation of the \textbf{VDP}, individual colours cannot be
    % assigned to the Pen. Therefore the screen is considered monochrome.

    % % ======================================================================
    % \subsubsection{Commands}
    % % ======================================================================

    % \begin{itemize}
    %     \item \textbf{BK} \textit{$<$number$>$}: (\textbf{Backward}) Moves the
    %     turtle backwards, a \textit{$<$number$>$} of pixels.
    %     \item \textbf{CS}: (\textbf{Clear Screen}) Clears the screen.
    %     \item \textbf{FD} \textit{$<$number$>$}: (\textbf{Forward}) Moves the
    %     turtle forward, a \textit{$<$number$>$} of pixels.
    %     \item \textbf{HM}: (\textbf{Home}) Moves (without drawing) the turtle
    %     to the middle of the screen.
    %     \item \textbf{HT}: (\textbf{Hide Turtle}) Hides the turtle.
    %     \item \textbf{LT} \textit{$<$degrees$>$}: (\textbf{Rotate Left}) Rotates
    %     the turtle left, by a number of \textit{$<$degrees$>$}.
    %     \item \textbf{PD}: (\textbf{Pen Down}) Puts the pen down, therefore the
    %     turtle draws while moving.
    %     \item \textbf{PU}: (\textbf{Pen Up}) Puts the pen up, therefore the
    %     turtle moves without drawing.
    %     \item \textbf{QL}: (\textbf{Quit LOGO}) Quits Logo and returns to
    %     DZOS's CLI.
    %     \item \textbf{RT} \textit{$<$degrees$>$}: (\textbf{Rotate Right})
    %     Rotates the turtle right, by a number of \textit{$<$degrees$>$}.
    %     \item \textbf{ST}: (\textbf{Show Turtle}) Shows the turtle.
    %     \item \textbf{SX} \textit{$<$X$>$}: (\textbf{Set Position X}) Puts the turtle to
    %     the specified \textit{$<$X$>$} position.
    %     \item \textbf{SY} \textit{$<$Y$>$}: (\textbf{Set Position Y}) Puts the turtle to
    %     the specified \textit{$<$Y$>$} position.
    % \end{itemize}